<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>In or Out</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            navy: "#0B1F2A",
            cream: "#FDF5D9",
            red: "#D43D3D",
          },
          boxShadow: {
            soft: "0 6px 24px rgba(0,0,0,0.18)",
          },
          keyframes: {
            jitter: {
              '0%,100%': { transform: 'translate(0,0) rotate(0deg)' },
              '25%': { transform: 'translate(-2px,1px) rotate(-4deg)' },
              '50%': { transform: 'translate(2px,-1px) rotate(4deg)' },
              '75%': { transform: 'translate(-1px,2px) rotate(-2deg)' },
            },
            pop: {
              '0%': { transform: 'scale(0.8)', opacity: 0 },
              '60%': { transform: 'scale(1.05)', opacity: 1 },
              '100%': { transform: 'scale(1)' },
            },
            confetti: {
              '0%': { transform: 'translateY(-20vh) rotate(0deg)' , opacity: 1 },
              '100%': { transform: 'translateY(120vh) rotate(540deg)', opacity: 1 },
            },
          },
          animation: {
            jitter: 'jitter 0.7s ease-in-out',
            pop: 'pop 320ms ease-out',
            confetti: 'confetti 2.4s linear forwards',
          }
        }
      }
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --navy:#0B1F2A; --cream:#FDF5D9; --red:#D43D3D;
    }
    body { background: var(--navy); color: var(--cream); font-family: "Space Grotesk", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .headline { font-family: "Libre Baskerville", serif; }
    .card { background: rgba(253,245,217,0.06); border: 1px solid rgba(253,245,217,0.08); backdrop-filter: blur(2px) }
    .btn { background: var(--cream); color: var(--navy); }
    .btn-red { background: var(--red); color: white; }
    .btn-outline { border:1px solid var(--cream); color: var(--cream); }
    .pip { width: .55rem; height: .55rem; border-radius: 999px; background: var(--cream); }
    .die { aspect-ratio: 1/1; background: rgba(253,245,217,0.12); border: 2px solid rgba(253,245,217,0.22); border-radius: 0.9rem; display:grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3,1fr); gap: .25rem; padding: .35rem; }
    .die.held { border-color: var(--red); box-shadow: 0 0 0 2px rgba(212,61,61,0.5) inset; }
    .die.empty { border-style: dashed; opacity: .6 }
    .pip.hide { opacity: 0 }
    .grid-center { display:flex; align-items:center; justify-content:center }
    .suspense-bg { background: rgba(11,31,42,0.9); }
    .bracket-item.out { opacity: .45; text-decoration: line-through; }
    .badge { border:1px solid rgba(253,245,217,0.25); background: rgba(253,245,217,0.08); }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen">
  <div id="root" class="max-w-screen-md mx-auto p-4 sm:p-6"></div>

  <script type="text/babel">

const { useState, useMemo, useRef, useEffect } = React;

// Utils
const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

function scoreDice(values){
  // In = at least one 1 and one 4
  const has1 = values.includes(1);
  const has4 = values.includes(4);
  if(!has1 || !has4) return {in:false, score:0};
  // Score = sum minus one 1 and one 4
  const sum = values.reduce((a,b)=>a+b,0);
  return {in:true, score: sum - 1 - 4};
}

function nextIndex(idx, order){
  const at = order.indexOf(idx);
  return order[(at+1) % order.length];
}

function sortOrderByRoundScores(players, roundScores){
  const aliveIdxs = players
    .map((p,i)=>({i,alive:!p.eliminated}))
    .filter(x=>x.alive)
    .map(x=>x.i);
  // Highest scorer goes last next round. We want ascending turn order with last being highest.
  const scored = aliveIdxs.map(i=>({i, score: roundScores[i] ?? 0}));
  scored.sort((a,b)=>a.score - b.score);
  return scored.map(x=>x.i);
}

// Components
function Header({children}) {
  return (
    <div className="flex items-center justify-between mb-4">
      <h1 className="headline text-2xl sm:text-3xl">In or Out</h1>
      <div className="text-sm opacity-80">{children}</div>
    </div>
  );
}

function Setup({ onStart }){
  const [count, setCount] = useState(4);
  const [names, setNames] = useState(["Player 1","Player 2","Player 3","Player 4"]);
  const [diceCount, setDiceCount] = useState(6);

  useEffect(()=>{
    if(names.length < count){
      setNames(prev => [...prev, ...Array.from({length: count - prev.length}, (_,k)=>`Player ${prev.length + k + 1}`)]);
    } else if(names.length > count){
      setNames(prev => prev.slice(0,count));
    }
  }, [count]);

  return (
    <div className="card rounded-2xl p-4 sm:p-6 shadow-soft animate-pop">
      <Header>
        <span className="badge rounded-full px-2 py-1 text-xs">Setup</span>
      </Header>

      <div className="space-y-6">
        <div>
          <label className="block text-sm mb-2">Players</label>
          <div className="grid grid-cols-4 gap-2">
            {[2,3,4,5,6].map(n=>(
              <button key={n}
                onClick={()=>setCount(n)}
                className={`rounded-xl py-2 ${count===n?'btn':'btn-outline hover:bg-cream/10'} transition`}>
                {n}
              </button>
            ))}
          </div>
        </div>

        <div className="space-y-2">
          {Array.from({length: count}).map((_,i)=>(
            <input key={i}
              className="w-full rounded-xl bg-transparent border border-cream/30 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-red"
              value={names[i] ?? ""}
              onChange={e=>{
                const arr=[...names]; arr[i]=e.target.value; setNames(arr);
              }}
              placeholder={`Player ${i+1} name`} />
          ))}
        </div>

        <div>
          <label className="block text-sm mb-2">Dice Count</label>
          <div className="grid grid-cols-3 gap-2">
            {[5,6,7].map(n=>(
              <button key={n}
                onClick={()=>setDiceCount(n)}
                className={`rounded-xl py-2 ${diceCount===n?'btn':'btn-outline hover:bg-cream/10'} transition`}>
                {n} dice
              </button>
            ))}
          </div>
        </div>

        <button
          onClick={()=>onStart(names.slice(0,count), diceCount)}
          className="w-full btn rounded-2xl py-3 text-lg font-semibold mt-2">
          Start Tournament
        </button>
      </div>
    </div>
  );
}

function Dice({ value, held, empty, onToggle, rolling }){
  const pipMap = {
    1: [5],
    2: [1,9],
    3: [1,5,9],
    4: [1,3,7,9],
    5: [1,3,5,7,9],
    6: [1,3,4,6,7,9],
  };
  return (
    <div onClick={onToggle}
      className={`die ${held?'held':''} ${empty?'empty':''} ${rolling?'animate-jitter':''} cursor-pointer select-none`}>
      {Array.from({length:9}).map((_,i)=>{
        const show = value && pipMap[value]?.includes(i+1);
        return <div key={i} className="grid-center">{show ? <div className="pip"></div> : <div className="pip hide"></div>}</div>
      })}
    </div>
  );
}

function PlayerBadge({name, active, out, score, inFlag, lastRoundTop}){
  return (
    <div className={`rounded-xl px-3 py-2 flex items-center gap-2 ${active?'bg-cream text-navy':'badge text-cream'}`}>
      <div className={`w-2 h-2 rounded-full ${out?'bg-red': active?'bg-navy':'bg-cream/70'}`}></div>
      <div className="font-medium">{name}</div>
      {typeof score === 'number' && !out && (
        <div className={`ml-auto text-xs ${active?'text-navy/70':'text-cream/70'}`}>
          {inFlag ? 'IN' : 'OUT'} · {score}
        </div>
      )}
      {lastRoundTop ? <span className={`text-[10px] ml-2 ${active?'text-navy/60':'text-cream/60'}`}>last to roll</span> : null}
    </div>
  );
}

function Bracket({ players }){
  return (
    <div className="card rounded-2xl p-4 shadow-soft">
      <div className="font-semibold mb-2">Bracket</div>
      <div className="space-y-2">
        {players.map((p,i)=>(
          <div key={i} className={`bracket-item ${p.eliminated?'out':''} flex items-center justify-between`}>
            <div className="flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${p.eliminated?'bg-red':'bg-cream/70'}`}></div>
              <span>{p.name}</span>
            </div>
            {p.eliminated && <span className="text-xs opacity-70">Out</span>}
          </div>
        ))}
      </div>
    </div>
  );
}

function SuspenseOverlay({ text }){
  return (
    <div className="fixed inset-0 z-40 suspense-bg grid place-items-center">
      <div className="text-center">
        <div className="headline text-3xl mb-2">Revealing…</div>
        <div className="opacity-80">{text}</div>
      </div>
    </div>
  );
}

function Victory({ winner, onReset }){
  // simple confetti
  const pieces = Array.from({length: 80});
  return (
    <div className="fixed inset-0 z-40 grid place-items-center">
      <div className="absolute inset-0 pointer-events-none">
        {pieces.map((_,i)=>(
          <div key={i}
               className="absolute w-2 h-3 rounded-sm"
               style={{
                 left: `${randInt(0,100)}%`,
                 top: `-10vh`,
                 background: i%3===0?'#FDF5D9':(i%3===1?'#D43D3D':'#ffffff'),
                 animation: `confetti ${1.8 + Math.random()*1.2}s linear ${Math.random()*0.6}s forwards`,
                 transform: `translateY(-20vh) rotate(${randInt(0,360)}deg)`
               }} />
        ))}
      </div>
      <div className="card rounded-3xl p-6 shadow-soft text-center animate-pop">
        <div className="headline text-3xl mb-2">Champion</div>
        <div className="text-lg opacity-90 mb-4">{winner.name}</div>
        <button className="btn-red rounded-2xl px-5 py-3 font-semibold" onClick={onReset}>Play Again</button>
      </div>
    </div>
  );
}

function Game(){
  const [players, setPlayers] = useState([]);
  const [order, setOrder] = useState([]);
  const [diceCount, setDiceCount] = useState(6);
  const [phase, setPhase] = useState("setup"); // setup | round | suspense | victory | tiebreak
  const [current, setCurrent] = useState(0);
  const [round, setRound] = useState(1);
  const [lastRoundScores, setLastRoundScores] = useState({});
  const [rolling, setRolling] = useState(false);

  // per turn dice state
  const [dice, setDice] = useState([]); // values or null
  const [held, setHeld] = useState([]); // bools
  const [firstRoll, setFirstRoll] = useState(true);
  const [turnDone, setTurnDone] = useState(false);
  const [inFlag, setInFlag] = useState(false);
  const [turnScore, setTurnScore] = useState(0);

  // tiebreaker
  const [tieGroup, setTieGroup] = useState([]); // indices
  const [tieScores, setTieScores] = useState({}); // idx -> score

  function start(names, dCount){
    const initPlayers = names.map(n=>({ name:n.trim()||"Player", eliminated:false }));
    setPlayers(initPlayers);
    const idxs = initPlayers.map((_,i)=>i);
    setOrder(idxs);
    setDiceCount(dCount);
    setPhase("round");
    setRound(1);
    resetTurnFor(order[0] ?? 0, dCount);
  }

  function resetTurnFor(playerIndex, dCount = diceCount){
    setCurrent(playerIndex);
    setDice(Array.from({length: dCount}).map(()=>null));
    setHeld(Array.from({length: dCount}).fill(false));
    setFirstRoll(true);
    setTurnDone(false);
    setInFlag(false);
    setTurnScore(0);
    setRolling(false);
  }

  function roll(){
    // must keep at least one die each roll unless firstRoll
    if(!firstRoll && held.filter(h=>h).length===0){
      alert("Keep at least one die before rolling.");
      return;
    }
    setRolling(true);
    // jitter then resolve
    setTimeout(()=>{
      setDice(prev => prev.map((v,i)=> held[i] ? v : randInt(1,6)));
      setFirstRoll(false);
      setRolling(false);
    }, 700);
  }

  useEffect(()=>{
    if(dice.length===0) return;
    if(dice.some(v=>v===null)) return;
    const keptAll = held.every(h=>h);
    const {in: ok, score} = scoreDice(dice);
    setInFlag(ok);
    setTurnScore(score);
    if(keptAll){
      setTurnDone(true);
    }
  }, [dice, held]);

  function toggleHold(i){
    if(firstRoll && dice[i]===null) return; // nothing to hold yet
    setHeld(prev=>{
      const copy=[...prev]; copy[i]=!copy[i]; return copy;
    });
  }

  function keepAll(){
    setHeld(Array.from({length:dice.length}).fill(true));
  }

  function endTurn(){
    // mark score
    const pid = current;
    const newRoundScores = { ...lastRoundScores, [pid]: turnScore };
    setLastRoundScores(newRoundScores);

    // next player or end round
    const nextIdx = nextIndex(pid, order);
    const isLastOfRound = nextIdx === order[0];

    if(isLastOfRound){
      // round end: evaluate elimination or tie-break
      const alive = players.map((p,i)=>({i, alive:!p.eliminated}));
      const aliveIdx = alive.filter(x=>x.alive).map(x=>x.i);
      const scores = aliveIdx.map(i=>({i, s:newRoundScores[i] ?? 0}));
      const minScore = Math.min(...scores.map(x=>x.s));
      const maxScore = Math.max(...scores.map(x=>x.s));
      const lowest = scores.filter(x=>x.s===minScore).map(x=>x.i);

      // set next round order based on scores
      const newOrder = sortOrderByRoundScores(players, newRoundScores);
      setOrder(newOrder);

      if(lowest.length>1){
        // tie-breaker
        setTieGroup(lowest);
        setTieScores({});
        setPhase("tiebreak");
        resetTurnFor(lowest[0]);
      } else {
        // eliminate one with suspense
        const outIdx = lowest[0];
        setPhase("suspense");
        setTimeout(()=>{
          setPlayers(prev=>{
            const copy=[...prev];
            copy[outIdx] = { ...copy[outIdx], eliminated:true };
            return copy;
          });
          const aliveCount = players.filter(p=>!p.eliminated).length - 1; // minus eliminated
          if(aliveCount<=1){
            setPhase("victory");
          } else {
            // next round
            setRound(r=>r+1);
            setLastRoundScores({});
            setPhase("round");
            // highest scorer rolls last next round already handled by newOrder
            resetTurnFor(newOrder[0]);
          }
        }, 1200);
      }
    } else {
      // next player's turn
      resetTurnFor(nextIdx);
    }
  }

  // tiebreak flow
  function endTieTurn(){
    const pid = current;
    const newTS = { ...tieScores, [pid]: turnScore };
    setTieScores(newTS);

    const idxInTie = tieGroup.indexOf(pid);
    const hasNext = idxInTie < tieGroup.length - 1;

    if(hasNext){
      resetTurnFor(tieGroup[idxInTie+1]);
    } else {
      // compare results
      const items = tieGroup.map(i=>({i, s:newTS[i] ?? 0}));
      const minS = Math.min(...items.map(x=>x.s));
      const cand = items.filter(x=>x.s===minS).map(x=>x.i);
      if(cand.length===1){
        // eliminate cand[0]
        setPhase("suspense");
        setTimeout(()=>{
          setPlayers(prev=>{
            const copy=[...prev];
            copy[cand[0]] = { ...copy[cand[0]], eliminated:true };
            return copy;
          });
          // next round
          setRound(r=>r+1);
          setLastRoundScores({});
          setPhase("round");
          // order remains from previous round
          const aliveOrder = order.filter(i=>!players[i].eliminated && i!==cand[0]);
          const startIdx = aliveOrder[0] ?? 0;
          resetTurnFor(startIdx);
        }, 1000);
      } else {
        // tie persists. repeat among cand
        setTieGroup(cand);
        setTieScores({});
        resetTurnFor(cand[0]);
      }
    }
  }

  function onReset(){
    setPlayers([]);
    setOrder([]);
    setDiceCount(6);
    setPhase("setup");
    setCurrent(0);
    setRound(1);
    setLastRoundScores({});
    setTieGroup([]);
    setTieScores({});
    setDice([]);
    setHeld([]);
    setFirstRoll(true);
    setTurnDone(false);
  }

  // derived
  const alivePlayers = players.filter(p=>!p.eliminated);
  const currentPlayer = players[current];

  if(phase==="setup"){
    return <Setup onStart={start} />
  }

  const topOfOrder = order[order.length-1];

  return (
    <div className="space-y-4">
      <Header>
        <div className="flex items-center gap-2">
          <span className="badge rounded-full px-2 py-1 text-xs">Round {round}</span>
          <span className="text-xs opacity-70">{alivePlayers.length} in play</span>
        </div>
      </Header>

      <div className="grid gap-4">
        <div className="card rounded-2xl p-4 shadow-soft">
          <div className="flex items-center justify-between mb-3">
            <div className="font-semibold">Current Turn</div>
            <div className="text-sm opacity-80">{phase==="tiebreak" ? "Tie-breaker" : "Standard round"}</div>
          </div>

          <PlayerBadge
            name={currentPlayer?.name ?? "Player"}
            active={true}
            out={false}
            score={turnScore}
            inFlag={inFlag}
            lastRoundTop={topOfOrder===current}
          />

          <div className="mt-4 grid grid-cols-5 sm:grid-cols-6 gap-2">
            {dice.map((v,i)=>(
              <Dice key={i}
                value={v}
                held={held[i]}
                empty={v===null}
                rolling={rolling}
                onToggle={()=>toggleHold(i)}
              />
            ))}
          </div>

          <div className="mt-4 grid grid-cols-2 gap-2">
            <button onClick={roll} disabled={rolling || turnDone}
              className={`rounded-2xl py-3 font-semibold ${turnDone?'btn-outline opacity-60':'btn'} disabled:opacity-60`}>
              {firstRoll ? "Roll" : "Re-roll"}
            </button>
            <button onClick={keepAll} disabled={turnDone || firstRoll}
              className="btn-outline rounded-2xl py-3 font-semibold disabled:opacity-60">
              Keep All
            </button>
          </div>

          <div className="mt-3 text-sm opacity-90">
            <div>Need at least one <span className="font-semibold">1</span> and one <span className="font-semibold">4</span> to score.</div>
            <div className="mt-1">Score: {inFlag ? turnScore : 0}</div>
          </div>

          <div className="mt-4">
            <button
              onClick={()=> phase==="tiebreak" ? endTieTurn() : endTurn()}
              disabled={!turnDone}
              className="btn-red rounded-2xl py-3 px-5 font-semibold w-full disabled:opacity-60">
              End Turn
            </button>
          </div>
        </div>

        <div className="grid gap-4 sm:grid-cols-2">
          <div className="card rounded-2xl p-4 shadow-soft">
            <div className="font-semibold mb-2">Turn Order</div>
            <div className="space-y-2">
              {order.filter(i=>!players[i].eliminated).map(i=>(
                <PlayerBadge
                  key={i}
                  name={players[i].name}
                  active={i===current}
                  out={false}
                  score={lastRoundScores[i]}
                  inFlag={(lastRoundScores[i] ?? 0) > 0}
                  lastRoundTop={topOfOrder===i}
                />
              ))}
            </div>
          </div>

          <Bracket players={players} />
        </div>
      </div>

      {phase==="suspense" && <SuspenseOverlay text="Lowest score will be eliminated." />}

      {phase==="victory" && (
        <Victory
          winner={players.find(p=>!p.eliminated) ?? {name:"Winner"}}
          onReset={onReset}
        />
      )}
    </div>
  );
}

function App(){
  return (
    <div>
      <Game/>
      <footer className="mt-6 text-center text-xs opacity-60">Theme: navy · cream · red</footer>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App/>);

  </script>
</body>
</html>
