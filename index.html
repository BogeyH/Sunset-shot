<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bogey Hound – The Walk In</title>

<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<style>
:root{
  --navy:#0B1F2A; --cream:#FDF0D5; --red:#C1121F;
  --rough:#2a4a3f; --fair:#2f6a58; --water:#1e587a; --sand:#d8c3a5; --tree:#163d33;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--navy);color:var(--cream);font-family:"Space Grotesk",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
h1,h2,h3{font-family:"Libre Baskerville",serif;margin:0}
button{font:600 16px "Space Grotesk";padding:12px 16px;border-radius:14px;border:0;background:var(--cream);color:var(--navy);cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,.25)}
button.secondary{background:transparent;color:var(--cream);border:2px solid rgba(253,240,213,.5)}
button.danger{background:#f25757;color:white}
button.ghost{background:transparent;border:1px dashed rgba(255,255,255,.35);color:var(--cream)}
.small{opacity:.85;font-size:12px}
.badge{display:inline-flex;gap:8px;align-items:center;font-weight:600;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14)}
.card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(6px);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.35)}
.row{display:flex;gap:12px;flex-wrap:wrap}
.stack{display:flex;flex-direction:column;gap:14px}
.center{display:grid;place-items:center;padding:16px}
.header,.footer{padding:12px 16px}
.brand{display:flex;gap:10px;align-items:center}
.brand .icon{width:36px;height:36px;border-radius:10px;background:var(--cream);display:grid;place-items:center;color:var(--navy);font-weight:800}
.pill{padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);font-weight:600}
.hr{height:1px;border:0;background:linear-gradient(90deg,transparent,rgba(255,255,255,.24),transparent)}
.hidden{display:none}
.scene{min-height:72dvh;position:relative}
.hud{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap}

/* Minimap */
.mini{width:min(940px,96vw);height:200px;border-radius:16px;background:#0e2a26;border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden}
.mini canvas{width:100%;height:100%}

/* Meters */
.meters{display:grid;gap:12px;width:min(940px,96vw)}
.meter{height:160px;border-radius:16px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden}
.meter canvas{width:100%;height:100%}
.meter .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;pointer-events:none}
.key{display:flex;gap:8px;align-items:center}
.dot{width:10px;height:10px;border-radius:50%;background:#fff;border:1px solid rgba(0,0,0,.35)}

/* Floating always-visible Pick Up */
#pickupFloating{
  position:fixed; left:12px; bottom:12px; z-index:50;
  padding:10px 14px; border-radius:12px; background:rgba(0,0,0,.4);
  border:1px solid rgba(255,255,255,.2); color:var(--cream); font-weight:700;
  backdrop-filter:blur(6px);
}
#pickupFloating:hover{background:rgba(0,0,0,.55)}
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 16px;border-radius:12px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.18)}
</style>
</head>
<body>
<div class="header">
  <div class="brand"><div class="icon">BH</div><div><div style="font-weight:800">Bogey Hound</div><div class="small">The Walk In</div></div></div>
</div>

<main id="scene" class="scene center"></main>

<button id="pickupFloating" title="End the hole now">Pick up</button>
<div class="footer"><div class="small">Built for the walk, not the leaderboard.</div></div>
<div id="toast" class="toast hidden"></div>

<script>
/* ========== Audio stubs (swap files later) ========== */
const SFX = {
  hit: new Howl({src:[],volume:.5}),
  splash: new Howl({src:[],volume:.5}),
  sand: new Howl({src:[],volume:.5}),
  cup: new Howl({src:[],volume:.6})
};

/* ========== Helpers ========== */
const $=(s,r=document)=>r.querySelector(s);
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const choice=a=>a[Math.floor(Math.random()*a.length)];
const lerp=(a,b,t)=>a+(b-a)*t;
const toast=$("#toast");
function showToast(txt,ms=1500){ toast.textContent=txt; toast.classList.remove("hidden"); clearTimeout(showToast._t); showToast._t=setTimeout(()=>toast.classList.add("hidden"),ms); }

/* ========== State ========== */
const STATE={
  distYds:409,onGreen:false,distFt:0,
  shots:0,penalties:0,finished:false,pickedUp:false,
  path:[{x:0.05,y:0.60}], _history:[]
};

const CLUBS={
  // Safe = wider perfect windows + slower meters
  driver:    {id:"driver",name:"The Big Dog",kind:"aggr",max:260,perf:0.10,anglePenalty:0.20,spdA:0.010,spdP:0.010,copy:"Let it fly."},
  drivingIr: {id:"drivingIr",name:"The Fairway Finder",kind:"safe",max:210,perf:0.28,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Short grass energy."},
  wood3:     {id:"wood3",name:"The Long Shot",kind:"aggr",max:235,perf:0.12,anglePenalty:0.18,spdA:0.009,spdP:0.009,copy:"Get it dancing."},
  iron5:     {id:"iron5",name:"The Layup",kind:"safe",max:190,perf:0.30,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Smart is sexy."},
  iron6:     {id:"iron6",name:"The Nudge",kind:"aggr",max:170,perf:0.14,anglePenalty:0.16,spdA:0.008,spdP:0.008,copy:"Thread it."},
  iron8:     {id:"iron8",name:"The Cozy One",kind:"safe",max:135,perf:0.32,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Pin-high vibes."},
  pw:        {id:"pw",name:"The Flighted Wedge",kind:"aggr",max:115,perf:0.16,anglePenalty:0.14,spdA:0.008,spdP:0.007,copy:"Send it soft."},
  lw60:      {id:"lw60",name:"The Float",kind:"safe",max:90,perf:0.34,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Up. Down. Close."},
  putter:    {id:"putter",name:"Putter",kind:"putt",max:60,perf:0.50,anglePenalty:0,spdA:0,spdP:0.004,copy:"Walk it in."}
};

const COMMENTARY={
  fairway:["Striped it.","Center-cut.","Rolling nice."],
  rough:["Found the long stuff, still playable.","Fluffy lie incoming."],
  trees:["Pine-cone collector.","90% air, 10% character."],
  water:["Nice day for a swim.","Splashy detour."],
  sand:["Beach break.","Sandy toes, steady pose."],
  green:["On the dance floor.","Showtime."],
  cup:["Walked it in.","Dead center."]
};

const scene=$("#scene");
$("#pickupFloating").onclick=finishPickup;

function resetState(){
  STATE.distYds=409; STATE.onGreen=false; STATE.distFt=0;
  STATE.shots=0; STATE.penalties=0; STATE.finished=false; STATE.pickedUp=false;
  STATE.path=[{x:0.05,y:0.60}]; STATE._history=[];
}

/* ========== Title & Leaderboard ========== */
function sceneTitle(){
  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:900px">
      <div class="badge">Bogey Hound · 18th · 409 yds</div>
      <h1>The sun is down,<br/>the vibes are up.<br/>Let’s walk it in.</h1>
      <p class="small">Power first. Angle second. Then enjoy the walk.</p>
      <div class="row">
        <button id="start">Start</button>
        <button class="secondary" id="lb">Leaderboard</button>
      </div>
    </div>`;
  $("#start").onclick=()=>{ resetState(); sceneClubSelect(); };
  $("#lb").onclick=sceneLeaderboard;
}
const LB_KEY="bh_walkin_lb_v4";
function loadLB(){ try{return JSON.parse(localStorage.getItem(LB_KEY)||"[]")}catch(e){return[]} }
function saveLB(i,s,tag){ const lb=loadLB(); lb.push({i,s,tag,t:Date.now()}); lb.sort((a,b)=>a.s-b.s||a.t-b.t); localStorage.setItem(LB_KEY,JSON.stringify(lb.slice(0,10))); }
function sceneLeaderboard(){
  const lb=loadLB();
  const rows = lb.map((r,i)=>`<tr><td>${i+1}</td><td>${r.i}</td><td>${r.s}</td><td>${r.tag||""}</td><td>${new Date(r.t).toLocaleDateString()}</td></tr>`).join("") || `<tr><td colspan="5" class="small">No scores yet.</td></tr>`;
  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:760px">
      <h2>Leaderboard</h2>
      <table class="leader" style="width:100%;border-collapse:collapse">
        <thead><tr><th>#</th><th>Initials</th><th>Score</th><th>Note</th><th>Date</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
      <div class="row"><button class="secondary" id="back">Back</button></div>
    </div>`;
  $("#back").onclick=sceneTitle;
}

/* ========== Minimap / Overhead ========== */
function drawMini(canvas, zoomGreen=false){
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const bb=canvas.getBoundingClientRect();
  canvas.width=Math.floor(bb.width*dpr); canvas.height=Math.floor(bb.height*dpr);
  const ctx=canvas.getContext("2d"); ctx.scale(dpr,dpr);

  // base
  ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);

  // Rough area left/right (wide strip)
  ctx.fillStyle=getCSS('--rough');
  roundRect(ctx, bb.width*0.02, bb.height*0.34, bb.width*0.96, bb.height*0.44, 28, true);

  // Fairway inside rough
  ctx.fillStyle=getCSS('--fair');
  roundRect(ctx, bb.width*0.06, bb.height*0.40, bb.width*0.88, bb.height*0.32, 26, true);

  // Pine trees lining TOP of fairway on the LEFT side
  const leftTopY = bb.height*0.40;
  const leftXStart = bb.width*0.06;
  ctx.fillStyle=getCSS('--tree');
  for(let x=leftXStart; x<bb.width*0.28; x+=18){
    drawPine(ctx, x, leftTopY-6, 14, 22);
  }

  // Water lining BOTTOM of fairway on the RIGHT side (long lagoon)
  ctx.fillStyle=getCSS('--water');
  ctx.beginPath();
  ctx.moveTo(bb.width*0.55, bb.height*0.72);
  ctx.quadraticCurveTo(bb.width*0.72, bb.height*0.84, bb.width*0.98, bb.height*0.80);
  ctx.lineTo(bb.width*0.98, bb.height*0.96);
  ctx.lineTo(bb.width*0.55, bb.height*0.96);
  ctx.closePath(); ctx.fill();

  // Sand LEFT of the green (short)
  const greenCx = bb.width*0.90, greenCy = bb.height*0.56, greenRx = bb.width*0.08, greenRy = bb.height*0.06;
  ctx.fillStyle=getCSS('--sand');
  ctx.beginPath();
  ctx.ellipse(greenCx - greenRx*0.60, greenCy+greenRy*0.10, greenRx*0.38, greenRy*0.26, 0, 0, Math.PI*2);
  ctx.fill();

  // Green (nothing but the flag)
  ctx.fillStyle="#2f7a63";
  ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();

  // Cup/flag
  const holeX = greenCx+greenRx*0.28, holeY = greenCy;
  ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
  ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();

  // Trace path
  const pts = STATE.path.map(p=>({x:lerp(0,bb.width,p.x), y:lerp(0,bb.height,p.y)}));

  // Zoom green view for putting
  if(zoomGreen || STATE.onGreen){
    const pad=12, gx=greenCx-greenRx-pad, gy=greenCy-greenRy-pad, gw=greenRx*2+pad*2, gh=greenRy*2+pad*2;
    ctx.save(); ctx.clearRect(0,0,bb.width,bb.height); ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);
    const sx=bb.width/gw, sy=bb.height/gh, s=Math.min(sx,sy);
    ctx.translate(-gx*s,-gy*s); ctx.scale(s,s);

    // re-draw green
    ctx.fillStyle="#2f7a63";
    ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();
    // cup/flag
    ctx.strokeStyle="#fff"; ctx.lineWidth=2/s; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
    ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();

    // trace
    ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2/s; ctx.beginPath();
    pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
    const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4/s,0,Math.PI*2); ctx.fill();
    ctx.restore();
    return;
  }

  ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2; ctx.beginPath();
  pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
  const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4,0,Math.PI*2); ctx.fill();
}

function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v); }
function roundRect(ctx,x,y,w,h,r,fill=true){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); fill?ctx.fill():ctx.stroke(); }
function drawPine(ctx,cx,baseY,w,h){
  ctx.fillStyle=getCSS('--tree');
  ctx.beginPath();
  ctx.moveTo(cx, baseY-h);
  ctx.lineTo(cx-w*0.6, baseY-h*0.55);
  ctx.lineTo(cx+w*0.6, baseY-h*0.55);
  ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(cx, baseY-h*0.55);
  ctx.lineTo(cx-w*0.8, baseY-h*0.15);
  ctx.lineTo(cx+w*0.8, baseY-h*0.15);
  ctx.closePath(); ctx.fill();
  ctx.fillRect(cx-2, baseY-h*0.15, 4, h*0.15);
}

/* ========== Club selection ========== */
function clubOptionsByDist(){
  const d=STATE.distYds;
  if(STATE.onGreen) return [{key:"putter",data:CLUBS.putter}];
  if(d>190) return [{key:"driver",data:CLUBS.driver},{key:"drivingIr",data:CLUBS.drivingIr}];
  if(d>120) return [{key:"wood3",data:CLUBS.wood3},{key:"iron5",data:CLUBS.iron5}];
  if(d>60)  return [{key:"iron6",data:CLUBS.iron6},{key:"iron8",data:CLUBS.iron8}];
  return [{key:"pw",data:CLUBS.pw},{key:"lw60",data:CLUBS.lw60}];
}

function sceneClubSelect(){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  // Minimap
  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen);

  const card=document.createElement("div"); card.className="card stack"; card.style.padding="18px";
  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  card.innerHTML=`
    <div class="hud">
      <div class="pill">${STATE.onGreen?"Putt":"Pick your pace"}</div>
      <div class="pill">Distance: ${distLabel}</div>
      <div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>
    </div>
    <div class="row" id="clubRow"></div>
    <div class="small">Hint: You’ll pick <strong>Power</strong> first, then <strong>Angle</strong>. Click the meter or use the buttons.</div>
  `;
  wrap.appendChild(card);

  const row=$("#clubRow",card);
  clubOptionsByDist().forEach(({key,data})=>{
    const c=document.createElement("div"); c.className="card stack"; c.style.padding="16px"; c.style.flex="1 1 260px";
    c.innerHTML=`
      <div class="badge">${data.kind==="putt"?"PUTT":(data.kind==="aggr"?"Aggressive":"Safe")}</div>
      <h2>${data.name}</h2>
      <div class="small">${data.copy}</div>
      <div class="row"><div class="pill">Max ${STATE.onGreen?Math.round(data.max)+" ft":Math.round(data.max)+" yds"}</div><div class="pill">Perfect ~${Math.round(data.perf*100)}%</div></div>
      <button>Use ${data.name}</button>`;
    $("button",c).onclick=()=>sceneSwingPowerFirst(key,data);
    row.appendChild(c);
  });
}

/* ========== Swing: POWER → then ANGLE ========== */
function sceneSwingPowerFirst(key, club){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen);

  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const header=document.createElement("div"); header.className="hud";
  header.innerHTML=`<div class="pill">1/2 – Select POWER · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  wrap.appendChild(header);

  // POWER meter with clear buttons
  const box=document.createElement("div"); box.className="meter";
  box.innerHTML=`
    <canvas id="power"></canvas>
    <div class="overlay"><div class="key"><span class="dot"></span><span id="powLabel">0</span></div><div class="key"><span class="dot" style="background:var(--red)"></span><span>Ideal zone</span></div></div>
  `;
  wrap.appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  ctrls.innerHTML=`<button class="secondary" id="back">Back</button><button id="toggleP">Pause</button><button id="lockP" class="danger">Lock Power</button>`;
  wrap.appendChild(ctrls);

  $("#back").onclick=sceneClubSelect;

  const pCVS=$("#power"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(pCVS);

  let cursorP=0, dirP=1, raf, paused=false;
  const spdP=club.spdP; const unit=STATE.onGreen?"ft":"yds";

  function requiredPower(){
    if(STATE.onGreen){
      const targetFt = clamp(STATE.distFt, 2, club.max);
      return clamp(targetFt/club.max, 0, 1);
    } else {
      let lie=1; const prev = lastOutcome();
      if(prev==="trees") lie=0.5;
      else if(prev==="roughL"||prev==="roughR"||prev==="sand") lie=0.9;
      const needed = clamp(STATE.distYds, 1, club.max*1.05);
      const effMax = club.max*lie;
      return clamp(needed/Math.max(1,effMax), 0, 1);
    }
  }
  function idealBandWidth(){ return STATE.onGreen ? (STATE.distFt<=8?0.48:STATE.distFt<=15?0.36:STATE.distFt<=30?0.28:0.22) : (club.kind==="safe"?0.32:0.18); }

  function drawPower(){
    const bb=pCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);

    // rail
    ctx.fillStyle="rgba(255,255,255,.09)";
    ctx.fillRect(bb.width*.08, bb.height*.12, bb.width*.84, bb.height*.76);

    // ticks + labels (big)
    ctx.fillStyle="rgba(255,255,255,.55)";
    ctx.textAlign="right"; ctx.font="700 22px 'Space Grotesk'";
    const maxMark=club.max;
    for(let i=0;i<=6;i++){
      const y=bb.height*.88 - (bb.height*.76)*(i/6);
      ctx.fillRect(bb.width*.08, y, bb.width*.84, 2);
      ctx.fillText(Math.round(maxMark*i/6)+" "+unit, bb.width*.075, y+8);
    }

    // ideal band
    const ideal=requiredPower(), band=idealBandWidth();
    const ph=bb.height*.76*band;
    const cyIdeal=bb.height*.88 - (bb.height*.76)*ideal;
    const py=clamp(cyIdeal - ph/2, bb.height*.12, bb.height*.88-ph);
    ctx.fillStyle="rgba(212,61,61,.32)";
    ctx.fillRect(bb.width*.08, py, bb.width*.84, ph);

    // cursor (animated)
    const cy = bb.height*.88 - cursorP*(bb.height*.76);
    ctx.fillStyle="#fff"; ctx.fillRect(bb.width*.50-10, cy-10, 20, 20);

    // readout
    const current = Math.round(maxMark*cursorP);
    $("#powLabel").textContent = current+" "+unit;
  }

  function tick(){
    if(!paused){
      cursorP += spdP*dirP;
      if(cursorP>1){cursorP=1;dirP=-1}
      if(cursorP<0){cursorP=0;dirP=1}
    }
    drawPower(); raf=requestAnimationFrame(tick);
  }
  tick();

  // intuitive inputs
  pCVS.addEventListener("click", ()=> lockPower(cursorP));
  $("#lockP").onclick=()=>lockPower(cursorP);
  $("#toggleP").onclick=()=>{ paused=!paused; $("#toggleP").textContent=paused?"Resume":"Pause"; };
  window.addEventListener("keydown", e=>{ if(e.code==="Space"){ e.preventDefault(); lockPower(cursorP);} });

  function lockPower(val){
    cancelAnimationFrame(raf);
    sceneSwingAngleSecond(key, club, clamp(val,0,1));
  }
}

/* ANGLE second */
function sceneSwingAngleSecond(key, club, powerVal){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen);

  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const header=document.createElement("div"); header.className="hud";
  header.innerHTML=`<div class="pill">2/2 – Select ANGLE · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  wrap.appendChild(header);

  const box=document.createElement("div"); box.className="meter";
  box.innerHTML=`
    <canvas id="angle"></canvas>
    <div class="overlay"><div class="key"><span class="dot" style="background:var(--red)"></span><span>Perfect zone</span></div><div class="key"><span class="dot" style="background:#bbb"></span><span>Hazard edges</span></div></div>
  `;
  wrap.appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  ctrls.innerHTML=`<button class="secondary" id="back">Back</button><button id="toggleA">Pause</button><button id="lockA" class="danger">Lock Angle</button><button id="hit" class="danger">Hit Shot</button>`;
  wrap.appendChild(ctrls);

  $("#back").onclick=sceneClubSelect;
  $("#hit").disabled=true;

  const aCVS=$("#angle"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(aCVS);

  let cursorA=0.5, dirA=1, raf, paused=false;
  const spdA=club.spdA;

  function drawAngle(){
    const bb=aCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);

    // rail
    ctx.fillStyle="rgba(255,255,255,.09)";
    ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84, bb.height*.08);

    // perfect zone
    const pw=bb.width*.84*club.perf;
    const px=bb.width*.08 + bb.width*.84*0.5 - pw/2;
    ctx.fillStyle="rgba(212,61,61,.32)";
    ctx.fillRect(px, bb.height*.46, pw, bb.height*.08);

    // hazard edges (anglePenalty)
    if(club.anglePenalty>0){
      ctx.fillStyle="rgba(255,255,255,.16)";
      ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
      ctx.fillRect(bb.width*(.92 - .84*club.anglePenalty), bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
    }

    // cursor
    const cx = bb.width*.08 + cursorA*bb.width*.84;
    ctx.fillStyle="#fff"; ctx.fillRect(cx-10, bb.height*.42, 20, bb.height*.16);
  }

  function tick(){
    if(!paused){
      cursorA += spdA*dirA;
      if(cursorA>1){cursorA=1;dirA=-1}
      if(cursorA<0){cursorA=0;dirA=1}
    }
    drawAngle(); raf=requestAnimationFrame(tick);
  }
  tick();

  aCVS.addEventListener("click", ()=>lockAngle(cursorA));
  $("#lockA").onclick=()=>lockAngle(cursorA);
  $("#toggleA").onclick=()=>{ paused=!paused; $("#toggleA").textContent=paused?"Resume":"Pause"; };
  window.addEventListener("keydown", e=>{ if(e.code==="Enter"){ e.preventDefault(); lockAngle(cursorA);} });

  function lockAngle(val){
    cancelAnimationFrame(raf);
    $("#hit").disabled=false;
    $("#hit").onclick=()=>resolveSwing(club, clamp(val,0,1), powerVal);
  }
}

/* ========== Outcome logic & scoring ========== */
const OUT={ TREES:"trees", ROUGH_L:"roughL", FAIRWAY:"fairway", ROUGH_R:"roughR", WATER:"water", SAND:"sand", GREEN:"green", CUP:"cup" };
function lastOutcome(){ const h=STATE._history; return h.length? h[h.length-1].outcome : null; }

function resolveSwing(club, angle, power){
  // every swing counts once
  STATE.shots++;

  // Putting (fixed advance)
  if(club.kind==="putt" || STATE.onGreen){
    STATE.onGreen=true;
    const target = clamp(STATE.distFt, 1, club.max);
    const hitFt = clamp(Math.round(power*club.max), 0, club.max);

    let tol = target<=6?4 : target<=12?3.5 : target<=20?3 : target<=40?2.5 : 2;
    if(Math.abs(hitFt - target) <= tol){
      STATE.distFt=0; pushPathToCup(); pushHistory(OUT.CUP, club.name); SFX.cup.play(); return finishRound();
    } else {
      const remaining = Math.max(1, Math.abs(target - hitFt));
      const frac = clamp(hitFt/target, 0, 0.98);
      pushPathTowardHole(frac);
      STATE.distFt = remaining;
      pushHistory(OUT.GREEN, club.name);
      showToast(choice(COMMENTARY.green));
      return sceneClubSelect();
    }
  }

  // Full shot
  let lie=1; const prev=lastOutcome();
  if(prev===OUT.TREES) lie=0.5;
  else if(prev===OUT.ROUGH_L||prev===OUT.ROUGH_R||prev===OUT.SAND) lie=0.9;

  const effMax=club.max*lie;
  let carry = clamp(power*effMax, 10, effMax);
  const before=STATE.distYds;
  let after=Math.max(0, before - carry);

  const lateral = angle - 0.5;
  let outcome = OUT.FAIRWAY;

  // Hazards: trees left, water right. Rough both sides baked into spreads.
  if(before>100){
    const pen=(angle < club.anglePenalty) || (angle > 1 - club.anglePenalty);
    if(pen) outcome = lateral>0 ? OUT.WATER : OUT.TREES;
  }

  // Near green classification
  if(after<=60 && outcome===OUT.FAIRWAY){
    if(lateral>0.22) outcome=OUT.SAND;             // short-right sand? Spec wants sand left of green (short). We'll use left-of-green earlier in minimap; keep gameplay forgiving: use right-lateral => sand
    else if(Math.abs(lateral)<=0.18) outcome=OUT.GREEN;
    else outcome=(lateral<0)?OUT.ROUGH_L:OUT.ROUGH_R;
  } else if(outcome===OUT.FAIRWAY){
    if(Math.abs(lateral)<=0.18) outcome=OUT.FAIRWAY;
    else outcome=(lateral<0)?OUT.ROUGH_L:OUT.ROUGH_R;
  }

  if(outcome===OUT.WATER){
    STATE.penalties++; showToast(choice(COMMENTARY.water)); SFX.splash.play();
    outcome=OUT.ROUGH_R;
  }

  if(outcome===OUT.GREEN){
    STATE.onGreen=true; STATE.distFt=Math.max(3, Math.round(after*3));
  } else {
    STATE.onGreen=false; STATE.distYds=Math.max(1, after);
  }

  pushPathByCarry(carry/before, lateral);

  let line="";
  if(outcome===OUT.FAIRWAY) line=choice(COMMENTARY.fairway);
  else if(outcome===OUT.ROUGH_L||outcome===OUT.ROUGH_R) line=choice(COMMENTARY.rough);
  else if(outcome===OUT.TREES) line=choice(COMMENTARY.trees);
  else if(outcome===OUT.SAND) line=choice(COMMENTARY.sand);
  else if(outcome===OUT.GREEN) line=choice(COMMENTARY.green);

  pushHistory(outcome, club.name);
  if(line) showToast(line);
  sceneClubSelect();
}

/* ========== Path & History ========== */
function pushPathByCarry(progress,lateral){
  const last=STATE.path[STATE.path.length-1];
  const newX = clamp(last.x + progress*0.82, 0.04, 0.97);
  const newY = clamp(last.y + lateral*0.60, 0.18, 0.82);
  STATE.path.push({x:newX, y:newY});
}
function pushPathTowardHole(frac){
  const last=STATE.path[STATE.path.length-1];
  const hole={x:0.97,y:0.56};
  STATE.path.push({x:lerp(last.x,hole.x,frac), y:lerp(last.y,hole.y,frac)});
}
function pushPathToCup(){ STATE.path.push({x:0.97,y:0.56}); }
function pushHistory(outcome,club){ STATE._history.push({outcome,club,shots:STATE.shots,pen:STATE.penalties,onGreen:STATE.onGreen,distYds:STATE.distYds,distFt:STATE.distFt}); }

/* ========== Finish & Pick-up ========== */
function finishRound(){
  const strokes=STATE.shots+STATE.penalties;
  finishScreen(strokes, null);
}
function finishPickup(){
  // always-visible pickup action
  const par=4, minScore=par+2;
  STATE.pickedUp=true;
  const strokes=Math.max(STATE.shots+STATE.penalties, minScore);
  finishScreen(strokes, "Picked up");
}
function finishScreen(strokes, tag){
  STATE.finished=true;
  const par=4, diff=strokes-par;
  const label = tag?tag:(diff<=-2?"Eagle":diff===-1?"Birdie":diff===0?"Par":diff===1?"Bogey":"+ "+diff);

  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:900px">
      <div class="badge">Final</div>
      <h2>${strokes} • ${label}</h2>
      <div class="row"><div class="pill">Shots: ${STATE.shots}</div><div class="pill">Penalties: ${STATE.penalties}</div></div>
      <div class="row">
        <button id="again">Restart</button>
        <button class="secondary" id="store">Visit the store</button>
        <button class="ghost" id="lb">Leaderboard</button>
      </div>
      <div class="row">
        <input id="init" maxlength="3" placeholder="ABC" style="padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.2);color:var(--cream)">
        <button id="save">Save Score</button>
      </div>
      <div id="msg" class="small"></div>
    </div>`;
  $("#again").onclick=sceneTitle;
  $("#store").onclick=()=>location.href="https://bogeyhound.com";
  $("#lb").onclick=sceneLeaderboard;
  $("#save").onclick=()=>{ const i=($("#init").value||"__").toUpperCase().replace(/[^A-Z]/g,"").slice(0,3).padEnd(3,"_"); saveLB(i,strokes, tag||""); $("#msg").textContent="Saved."; };
}

/* ========== Boot ========== */
sceneTitle();
</script>
</body>
</html>
