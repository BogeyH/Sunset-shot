<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>One‑Four Dice Tournament</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root{
      --navy:#0B1F2A; /* primary */
      --cream:#FDF5D9; /* bg/cards */
      --red:#D43D3D; /* accent */
    }
    body { background: radial-gradient(1200px 800px at 50% -10%, #103047, var(--navy) 60%); }
    .die { position: relative; }
    .pip { width:10px; height:10px; border-radius:50%; background: currentColor; position:absolute; opacity:.95; }/* Animations */
@keyframes wiggle { 0%{transform:rotate(0deg)} 25%{transform:rotate(-6deg)} 50%{transform:rotate(6deg)} 75%{transform:rotate(-3deg)} 100%{transform:rotate(0deg)} }
@keyframes pop { from{transform:scale(.9); opacity:.5} to{transform:scale(1); opacity:1} }
.rolling { animation: wiggle .4s ease-in-out infinite; }
.pop { animation: pop .18s ease-out; }

/* Confetti */
.confetti { position: fixed; inset: 0; pointer-events: none; overflow: hidden; }
.confetti i { position:absolute; width:10px; height:16px; background: var(--cream); opacity:.9; transform: rotate(0deg);}
@keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity: .9; } }

  </style>
</head>
<body class="text-[var(--cream)] antialiased">
  <div id="root"></div>
  <script type="text/babel">
    const { useMemo, useState, useEffect, useRef } = React;// --- helpers ---
const rollMany = (n) => Array.from({ length: n }, () => 1 + Math.floor(Math.random()*6));
const sum = (a) => a.reduce((x,y)=>x+y,0);
const needIn = (a) => a.includes(1) && a.includes(4);

function App(){
  const [phase, setPhase] = useState('setup');
  const [diceCount, setDiceCount] = useState(5); // 5, 6, 7
  const [names, setNames] = useState(['','']);

  // tournament state
  const [active, setActive] = useState([]); // players still in, in play order
  const [roundNum, setRoundNum] = useState(1);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [scores, setScores] = useState({}); // {name: score} for current round (or tie-break)
  const [tieGroup, setTieGroup] = useState(null); // array of names if tie for lowest
  const [history, setHistory] = useState([]); // [{round, scores, eliminated}]
  const [revealing, setRevealing] = useState(false);

  // turn state
  const [turnName, setTurnName] = useState('');
  const [dice, setDice] = useState([]);
  const [kept, setKept] = useState([]);
  const [selectKeep, setSelectKeep] = useState([]);
  const [roundOver, setRoundOver] = useState(false);
  const [message, setMessage] = useState('');
  const [score, setScore] = useState(0);
  const [rolling, setRolling] = useState(false);
  const [showConfetti, setShowConfetti] = useState(false);

  // ---- setup ----
  const addPlayer = () => setNames(n => [...n, '']);
  const removePlayer = (i) => setNames(n => n.length>2 ? n.filter((_,idx)=>idx!==i) : n);

  const startTournament = () => {
    const players = names.map(s=>s.trim()).filter(Boolean);
    if (players.length < 2) return alert('Need at least 2 players.');
    setActive(players);
    setRoundNum(1);
    setCurrentIndex(0);
    setScores({});
    setTieGroup(null);
    setHistory([]);
    setPhase('play');
  };

  // begin first turn when entering play or when index changes
  useEffect(()=>{
    if (phase !== 'play') return;
    const roster = tieGroup ? tieGroup : active;
    if (!roster.length) return;
    if (currentIndex >= roster.length) return; // will be advanced by evaluation
    beginTurn(roster[currentIndex]);
  }, [phase, currentIndex, tieGroup]);

  function beginTurn(name){
    setTurnName(name);
    setDice(rollMany(diceCount));
    setKept(Array(diceCount).fill(false));
    setSelectKeep(Array(diceCount).fill(false));
    setRoundOver(false);
    setScore(0);
    setMessage('Select at least 1 die to keep, then Keep & Roll.');
  }

  // ---- roll/keep logic ----
  const keptCount = useMemo(()=> kept.filter(Boolean).length, [kept]);

  const onToggle = (i) => {
    if (roundOver || kept[i]) return;
    const next = [...selectKeep];
    next[i] = !next[i];
    setSelectKeep(next);
  };

  // Rolling animation: jitter values for 700ms before settling
  function animateRollApply(newKept){
    const remaining = newKept.reduce((a,k)=>a+(k?0:1),0);
    if (remaining === 0){
      const finalScore = needIn(dice) ? sum(dice) : 0;
      setRoundOver(true);
      setScore(finalScore);
      setMessage(finalScore>0 ? 'Round over. You are in.' : 'Round over. No 1+4. Score 0.');
      return;
    }
    setRolling(true);
    const start = performance.now();
    const jitter = () => {
      const t = performance.now() - start;
      const temp = [...dice];
      for(let i=0;i<dice.length;i++) if(!newKept[i]) temp[i] = 1 + Math.floor(Math.random()*6);
      setDice(temp);
      if (t < 700){ requestAnimationFrame(jitter); }
      else {
        const rolled = rollMany(remaining);
        const nextDice=[]; let r=0;
        for (let i=0;i<dice.length;i++) nextDice[i] = newKept[i] ? dice[i] : rolled[r++];
        setDice(nextDice);
        setKept(newKept);
        setSelectKeep(Array(dice.length).fill(false));
        setRolling(false);
        setMessage('Nice. Pick at least one more to keep.');
      }
    };
    requestAnimationFrame(jitter);
  }

  const keepAndRoll = () => {
    if (roundOver) return;
    const toKeep = selectKeep.filter(Boolean).length;
    if (keptCount < dice.length && toKeep === 0){
      setMessage('You must keep at least 1 die before rolling.');
      return;
    }
    const newKept = kept.map((k,i)=> k || selectKeep[i]);
    animateRollApply(newKept);
  };

  const endNow = () => {
    if (roundOver) return;
    // brief suspense before lock
    setRolling(true);
    setTimeout(()=>{
      const finalScore = needIn(dice) ? sum(dice) : 0;
      setKept(Array(dice.length).fill(true));
      setSelectKeep(Array(dice.length).fill(false));
      setRoundOver(true);
      setScore(finalScore);
      setMessage(finalScore>0 ? 'Round over. You are in.' : 'Round over. No 1+4. Score 0.');
      setRolling(false);
    }, 500);
  };

  const submitScore = () => {
    const roster = tieGroup ? tieGroup : active;
    const name = roster[currentIndex];
    const nextScores = { ...scores, [name]: score };
    setScores(nextScores);
    const nextIndex = currentIndex + 1;
    if (nextIndex < roster.length){
      setCurrentIndex(nextIndex);
    } else {
      evaluateRoundWithSuspense(nextScores, roster);
    }
  };

  function evaluateRoundWithSuspense(sc, roster){
    setRevealing(true);
    setTimeout(()=>{ // suspense pause
      setRevealing(false);
      evaluateRound(sc, roster);
    }, 1200);
  }

  function evaluateRound(sc, roster){
    // everyone rolled: eliminate lowest; highest goes last next round
    const entries = roster.map(n=> ({ name:n, s: sc[n] ?? 0 }));
    const min = Math.min(...entries.map(e=> e.s));
    const candidatesLowest = entries.filter(e=> e.s === min).map(e=> e.name);
    if (candidatesLowest.length > 1){
      setTieGroup(candidatesLowest);
      setScores({});
      setCurrentIndex(0);
      return;
    }
    const eliminated = candidatesLowest[0];
    let survivors = active.filter(n=> n !== eliminated);
    const max = Math.max(...entries.filter(e=> e.name !== eliminated).map(e=> e.s));
    const topNames = entries.filter(e=> e.name !== eliminated && e.s === max).map(e=> e.name);
    const nonTop = survivors.filter(n=> !topNames.includes(n));
    const nextOrder = [...nonTop, ...survivors.filter(n=> topNames.includes(n))];

    setHistory(h => [...h, { round: roundNum, scores: sc, eliminated }]);

    if (nextOrder.length === 1){
      setActive(nextOrder);
      setPhase('done');
      setTimeout(()=> setShowConfetti(true), 50);
      return;
    }
    setActive(nextOrder);
    setRoundNum(r => r+1);
    setScores({});
    setTieGroup(null);
    setCurrentIndex(0);
  }

  // ---- views ----
  if (phase === 'setup') return (
    <div className="min-h-screen flex items-center justify-center px-4 py-8">
      <div className="w-full max-w-xl bg-[rgba(253,245,217,0.1)] backdrop-blur rounded-3xl p-5 shadow-xl">
        <h1 className="text-2xl font-semibold mb-1">One‑Four Dice</h1>
        <p className="text-sm text-[rgba(253,245,217,0.8)] mb-4">Pick rules. Add players. All roll; lowest is out. Highest rolls last next round.</p>

        <div className="grid grid-cols-2 gap-3 mb-4">
          <div className="bg-[rgba(253,245,217,0.1)] rounded-2xl p-3">
            <div className="text-xs text-[rgba(253,245,217,0.8)] mb-1">Dice per round</div>
            <div className="flex gap-2">
              <button className={`${diceCount===5?'bg-[var(--cream)] text-[var(--navy)]':'bg-[rgba(253,245,217,0.2)]'} px-3 py-2 rounded-xl font-semibold`} onClick={()=>setDiceCount(5)}>5</button>
              <button className={`${diceCount===6?'bg-[var(--cream)] text-[var(--navy)]':'bg-[rgba(253,245,217,0.2)]'} px-3 py-2 rounded-xl font-semibold`} onClick={()=>setDiceCount(6)}>6</button>
              <button className={`${diceCount===7?'bg-[var(--cream)] text-[var(--navy)]':'bg-[rgba(253,245,217,0.2)]'} px-3 py-2 rounded-xl font-semibold`} onClick={()=>setDiceCount(7)}>7</button>
            </div>
          </div>
          <div className="bg-[rgba(253,245,217,0.1)] rounded-2xl p-3">
            <div className="text-xs text-[rgba(253,245,217,0.8)] mb-1">Players</div>
            <div className="flex items-center gap-2">
              <button className="px-3 py-2 rounded-xl bg-[rgba(253,245,217,0.2)]" onClick={addPlayer}>+ Add</button>
            </div>
          </div>
        </div>

        <div className="space-y-2 max-h-64 overflow-auto pr-1">
          {names.map((n,i)=> (
            <div key={i} className="flex gap-2 items-center">
              <input className="flex-1 px-3 py-2 rounded-xl bg-[rgba(253,245,217,0.15)] focus:bg-[rgba(253,245,217,0.2)] outline-none text-[var(--cream)] placeholder:[color:rgba(253,245,217,0.7)]" placeholder={`Player ${i+1} name`} value={n} onChange={(e)=> setNames(names.map((v,idx)=> idx===i? e.target.value : v))} />
              <button className="px-3 py-2 rounded-xl bg-[rgba(253,245,217,0.15)]" onClick={()=>removePlayer(i)}>Remove</button>
            </div>
          ))}
        </div>

        <div className="mt-4 flex justify-between items-center">
          <RulesSummary />
          <button className="px-4 py-3 rounded-2xl bg-[var(--red)] text-[var(--cream)] font-semibold" onClick={startTournament}>Start</button>
        </div>
      </div>
    </div>
  );

  if (phase === 'play'){
    const roster = tieGroup ? tieGroup : active;
    const who = roster[currentIndex] || '';
    const everyoneScored = roster.every(n => scores[n] !== undefined);
    return (
      <div className="min-h-screen px-4 py-6 flex flex-col items-center">
        <div className="w-full max-w-5xl grid md:grid-cols-[1fr_420px] gap-4">
          <Leaderboard active={active} scores={scores} roundNum={roundNum} tieGroup={tieGroup} history={history} current={who} revealing={revealing} />

          <div className="bg-[rgba(253,245,217,0.1)] rounded-3xl p-4">
            <h2 className="text-xl font-semibold mb-1">Round {roundNum}{tieGroup? ' • Tie‑break' : ''}</h2>
            <div className="text-sm text-[rgba(253,245,217,0.8)] mb-3">Current: <span className="font-semibold text-[var(--cream)]">{who}</span></div>

            <DiceTray dice={dice} kept={kept} selectKeep={selectKeep} onToggle={(i)=> onToggle(i)} disabled={roundOver || rolling} rolling={rolling} />

            <div className="grid grid-cols-3 gap-2 mb-2">
              <Stat label="Kept" value={`${kept.filter(Boolean).length}/${dice.length}`} />
              <Stat label="Score" value={roundOver ? score : '—'} hint={roundOver ? (score>0 ? 'in' : 'no 1+4') : undefined} />
              <Stat label="Dice" value={dice.length} />
            </div>

            <div className="flex gap-2">
              <button className={`flex-1 px-4 py-3 rounded-2xl font-semibold ${(!roundOver && (kept.filter(Boolean).length<dice.length) && selectKeep.some(Boolean) && !rolling)? 'bg-[var(--red)] text-[var(--cream)]':'bg-[rgba(253,245,217,0.2)] text-[var(--cream)]/80'}`} onClick={keepAndRoll} disabled={roundOver || rolling || !(kept.filter(Boolean).length<dice.length) || !selectKeep.some(Boolean)}>Keep & Roll</button>
              <button className="px-4 py-3 rounded-2xl bg-[rgba(253,245,217,0.15)] font-semibold" onClick={endNow} disabled={roundOver || rolling}>End Now</button>
              <button className="px-4 py-3 rounded-2xl bg-[var(--cream)] text-[var(--navy)] font-semibold" onClick={()=> beginTurn(who)} disabled={rolling}>Re‑roll</button>
            </div>

            <p className="mt-2 text-sm text-[rgba(253,245,217,0.8)]">{rolling? 'Rolling…' : revealing? 'Revealing…' : message}</p>

            {roundOver && (
              <button className="mt-3 w-full px-4 py-3 rounded-2xl bg-[var(--cream)] text-[var(--navy)] font-semibold" onClick={submitScore} disabled={rolling}>Submit Score</button>
            )}

            {everyoneScored && !tieGroup && (
              <div className="mt-3 text-sm text-[rgba(253,245,217,0.8)]">All scores in. Lowest will be eliminated. Highest will roll last next round.</div>
            )}
          </div>
        </div>

        {revealing && <RevealCurtain />}
      </div>
    );
  }

  if (phase === 'done'){
    const champ = active[0];
    return (
      <div className="min-h-screen flex items-center justify-center px-4 py-8">
        <div className="w-full max-w-md bg-[rgba(253,245,217,0.1)] rounded-3xl p-6 text-center relative overflow-hidden">
          <h2 className="text-2xl font-semibold mb-2">Champion</h2>
          <div className="text-4xl font-bold text-[var(--cream)] mb-2 pop">{champ}</div>
          <div className="text-sm text-[rgba(253,245,217,0.85)] mb-4">One‑Four Dice Tournament Winner</div>
          <button className="px-4 py-3 rounded-2xl bg-[var(--red)] text-[var(--cream)] font-semibold" onClick={()=>{ setShowConfetti(false); setPhase('setup'); setActive([]); setRoundNum(1); setCurrentIndex(0); setScores({}); setTieGroup(null); setHistory([]); }}>New Tournament</button>
          {showConfetti && <Confetti />}
          <TrophyRays />
        </div>
      </div>
    );
  }
}

function RevealCurtain(){
  return (
    <div className="fixed inset-0 flex items-center justify-center bg-[rgba(11,31,42,0.7)] backdrop-blur-sm z-40">
      <div className="text-4xl font-bold text-[var(--cream)] animate-pulse">Revealing…</div>
    </div>
  );
}

function Stat({label, value, hint}){
  return (
    <div className="bg-[rgba(253,245,217,0.1)] rounded-2xl p-3 text-center">
      <div className="text-xs uppercase text-[rgba(253,245,217,0.8)]">{label}</div>
      <div className="text-xl font-semibold text-[var(--cream)]">{value}</div>
      {hint && <div className="text-[10px] text-[rgba(253,245,217,0.8)]">{hint}</div>}
    </div>
  );
}

function RulesSummary(){
  return (
    <div className="text-sm text-[rgba(253,245,217,0.85)]">
      <div className="font-semibold text-[var(--cream)]">Rules</div>
      <ul className="list-disc pl-5 space-y-1">
        <li>Roll 5, 6, or 7 dice. Keep at least 1 each roll.</li>
        <li>Round ends when all dice are kept.</li>
        <li>You must have a 1 and a 4 to score.</li>
        <li>If in, score = sum of all dice. Else score = 0.</li>
        <li>All players roll each round. Lowest score is eliminated. Highest scorer rolls last next round.</li>
      </ul>
    </div>
  );
}

function DiceTray({ dice, kept, selectKeep, onToggle, disabled, rolling}){
  return (
    <div className="grid gap-2 mb-4" style={{gridTemplateColumns: `repeat(${dice.length}, minmax(36px, 1fr))`}}>
      {dice.map((v,i)=> (
        <Die key={i} value={v} kept={kept[i]} selected={selectKeep[i]} onClick={()=> onToggle(i)} disabled={disabled} rolling={rolling && !kept[i]} />
      ))}
    </div>
  );
}

function Die({ value, kept, selected, onClick, disabled, rolling }){
  const base = 'die aspect-square rounded-2xl flex items-center justify-center shadow transition-transform relative overflow-hidden';
  let classes = '';
  if (kept) classes = 'bg-[var(--cream)] text-[var(--navy)] pop';
  else if (selected) classes = 'bg-[var(--red)] text-[var(--cream)] scale-105';
  else classes = 'bg-[rgba(253,245,217,0.15)] text-[var(--cream)]';
  return (
    <button onClick={onClick} disabled={disabled||kept} className={`${base} ${classes} ${rolling? 'rolling':''}`} aria-label={`Die${kept? ' kept': selected? ' selected':''}`}>
      <Pips n={value} />
    </button>
  );
}

function Pips({n}){
  const spots = {
    1: [[50,50]],
    2: [[25,25],[75,75]],
    3: [[25,25],[50,50],[75,75]],
    4: [[25,25],[75,25],[25,75],[75,75]],
    5: [[25,25],[75,25],[50,50],[25,75],[75,75]],
    6: [[25,25],[75,25],[25,50],[75,50],[25,75],[75,75]]
  }[n] || [];
  return (
    <>
      {spots.map(([x,y],i)=> <span key={i} className="pip" style={{left:`calc(${x}% - 5px)`, top:`calc(${y}% - 5px)`}} />)}
    </>
  );
}

function Leaderboard({ active, scores, roundNum, tieGroup, history, current, revealing }){
  return (
    <div className="bg-[rgba(253,245,217,0.1)] rounded-3xl p-4 overflow-auto relative">
      <h2 className="text-xl font-semibold mb-3">Leaderboard</h2>
      <div className="space-y-2">
        {active.map((name)=>{
          const s = scores[name];
          const isCurrent = current === name;
          const inTie = tieGroup ? tieGroup.includes(name) : false;
          return (
            <div key={name} className={`rounded-2xl p-3 flex items-center justify-between ${isCurrent? 'bg-[var(--cream)] text-[var(--navy)]':'bg-[rgba(253,245,217,0.12)]'}`}>
              <div className="font-semibold truncate">{name}</div>
              <div className="text-sm opacity-80">{s===undefined? '—' : s}{inTie? ' • tie' : ''}</div>
            </div>
          );
        })}
      </div>

      {history.length>0 && (
        <div className="mt-4">
          <div className="text-sm font-semibold mb-2">Rounds</div>
          <div className="space-y-2 max-h-48 overflow-auto pr-1">
            {history.map((r,i)=> (
              <div key={i} className="bg-[rgba(253,245,217,0.08)] rounded-2xl p-3 text-sm">
                <div className="mb-1">Round {r.round} • Eliminated: <span className="font-semibold">{r.eliminated}</span></div>
                <div className="flex flex-wrap gap-2">
                  {Object.entries(r.scores).map(([n,s])=> (
                    <span key={n} className="px-2 py-1 bg-[rgba(253,245,217,0.15)] rounded-lg">{n}: {s}</span>
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {revealing && (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="px-4 py-2 rounded-xl bg-[var(--cream)] text-[var(--navy)] font-semibold shadow">Revealing scores…</div>
        </div>
      )}
    </div>
  );
}

function Confetti(){
  const ref = useRef(null);
  useEffect(()=>{
    const el = ref.current;
    if(!el) return;
    const W = window.innerWidth;
    const N = 120;
    for(let i=0;i<N;i++){
      const piece = document.createElement('i');
      piece.style.left = Math.random()*W + 'px';
      piece.style.top = -20 - Math.random()*200 + 'px';
      piece.style.background = i%3===0? 'var(--red)': (i%3===1? 'var(--cream)' : '#ffffff');
      piece.style.transform = `rotate(${Math.random()*180}deg)`;
      piece.style.animation = `fall ${2 + Math.random()*2.2}s linear ${Math.random()*0.6}s forwards`;
      el.appendChild(piece);
    }
    const t = setTimeout(()=> { if(el) el.innerHTML=''; }, 4000);
    return ()=> clearTimeout(t);
  },[]);
  return <div ref={ref} className="confetti" />;
}

function TrophyRays(){
  return (
    <svg className="absolute -top-10 left-1/2 -translate-x-1/2 opacity-30" width="500" height="220" viewBox="0 0 500 220" fill="none">
      {[...Array(16)].map((_,i)=> (
        <line key={i} x1="250" y1="0" x2={250 + 230*Math.cos((i/16)*Math.PI)} y2={110 + 100*Math.sin((i/16)*Math.PI)} stroke="#FDF5D9" strokeWidth="2" />
      ))}
    </svg>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App/>);

  </script>
</body>
</html>
