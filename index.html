Here’s a single-file replacement with:

Single-tap putting (power only; distance-true make %).

Slower pacing + vibes: pauses between shots, typed remarks, club reassurance, and slow arced ball flight with loft by club.

Angle meter still shifts the ideal band toward the hole on full shots.


Paste this over your file.

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bogey Hound – The Walk In</title>
<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>
<style>
:root{
  --navy:#0B1F2A; --cream:#FDF0D5; --red:#C1121F;
  --rough:#2a4a3f; --fair:#2f6a58; --water:#1e587a; --sand:#d8c3a5; --tree:#163d33;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--navy);color:var(--cream);font-family:"Space Grotesk",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
h1,h2,h3{font-family:"Libre Baskerville",serif;margin:0}
button{font:600 16px "Space Grotesk";padding:12px 16px;border-radius:14px;border:0;background:var(--cream);color:var(--navy);cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,.25)}
button.secondary{background:transparent;color:var(--cream);border:2px solid rgba(253,240,213,.5)}
button.danger{background:#f25757;color:white}
button.ghost{background:transparent;border:1px dashed rgba(255,255,255,.35);color:var(--cream)}
.small{opacity:.85;font-size:12px}
.badge{display:inline-flex;gap:8px;align-items:center;font-weight:600;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14)}
.card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(6px);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.35)}
.row{display:flex;gap:12px;flex-wrap:wrap}
.stack{display:flex;flex-direction:column;gap:14px}
.center{display:grid;place-items:center;padding:16px}
.header,.footer{padding:12px 16px}
.brand{display:flex;gap:10px;align-items:center}
.brand .icon{width:36px;height:36px;border-radius:10px;background:var(--cream);display:grid;place-items:center;color:var(--navy);font-weight:800}
.pill{padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);font-weight:600}
.hidden{display:none}
.scene{min-height:72dvh;position:relative}
.hud{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap}

/* Minimap */
.mini{width:min(960px,96vw);height:200px;border-radius:16px;background:#0e2a26;border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden}
.mini canvas{width:100%;height:100%}

/* Meters */
.meters{display:grid;gap:12px;width:min(960px,96vw)}
.meter{height:160px;border-radius:16px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden}
.meter canvas{width:100%;height:100%}
.meter .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
.readout{font:800 28px "Space Grotesk";background:rgba(0,0,0,.35);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.18)}

/* Always-visible Pick Up */
#pickupFloating{
  position:fixed; left:12px; bottom:12px; z-index:50;
  padding:10px 14px; border-radius:12px; background:rgba(0,0,0,.4);
  border:1px solid rgba(255,255,255,.2); color:var(--cream); font-weight:700;
  backdrop-filter:blur(6px);
}
#pickupFloating:hover{background:rgba(0,0,0,.55)}
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 16px;border-radius:12px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.18);max-width:min(92vw,720px)}
</style>
</head>
<body>
<div class="header">
  <div class="brand"><div class="icon">BH</div><div><div style="font-weight:800">Bogey Hound</div><div class="small">The Walk In</div></div></div>
</div>

<main id="scene" class="scene center"></main>

<button id="pickupFloating" title="End the hole now">Pick up</button>
<div class="footer"><div class="small">Built for the walk, not the leaderboard.</div></div>
<div id="toast" class="toast hidden"></div>

<script>
/* ===== Audio stubs ===== */
const SFX = { hit:new Howl({src:[],volume:.5}), splash:new Howl({src:[],volume:.5}), sand:new Howl({src:[],volume:.5}), cup:new Howl({src:[],volume:.6}) };

/* ===== Helpers ===== */
const $=(s,r=document)=>r.querySelector(s);
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const choice=a=>a[Math.floor(Math.random()*a.length)];
const lerp=(a,b,t)=>a+(b-a)*t;
const toast=$("#toast");
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }
async function typeToast(txt, charMs=22, holdMs=800){
  toast.textContent=""; toast.classList.remove("hidden");
  for(const ch of txt){ toast.textContent+=ch; await sleep(charMs); }
  await sleep(holdMs);
  toast.classList.add("hidden");
}

/* ===== NEW: hole constant + putting/aim helpers + vibes/pacing ===== */
const HOLE = { x:0.97, y:0.56 };

const PACE = {
  betweenShots: 900,     // idle gap after remarks
  flightBase: 700,       // base flight duration
  flightPerUnit: 1800,   // added per normalized distance
  puttFlightMin: 450     // short roll for made/missed putts
};

// Approx PGA-Tour-ish make % by distance (ft). Linear interp between anchors.
function pgaMakeProb(ft){
  const T = [
    [1,0.995],[2,0.990],[3,0.970],[4,0.910],[5,0.820],
    [6,0.730],[7,0.640],[8,0.570],[9,0.520],[10,0.440],
    [12,0.350],[15,0.300],[20,0.200],[25,0.150],[30,0.100],
    [40,0.060],[50,0.040],[60,0.030]
  ];
  if(ft<=T[0][0]) return T[0][1];
  if(ft>=T[T.length-1][0]) return T[T.length-1][1];
  for(let i=0;i<T.length-1;i++){
    const [x1,y1]=T[i], [x2,y2]=T[i+1];
    if(ft>=x1 && ft<=x2){
      const t=(ft-x1)/(x2-x1);
      return y1+(y2-y1)*t;
    }
  }
  return 0.05;
}
function puttPowerTolerance(ft){
  if(ft<=4)  return 12;
  if(ft<=8)  return 8;
  if(ft<=12) return 6;
  if(ft<=20) return 5;
  if(ft<=30) return 4;
  if(ft<=50) return 3;
  return 2.5;
}
function puttLineWindow(ft){
  const w = 0.28 - 0.0035*Math.min(ft,60);
  return clamp(w, 0.06, 0.30);
}
function idealAngleCenter(isPutting=false){
  const last = STATE.path[STATE.path.length-1];
  const dy = HOLE.y - last.y;
  const k = isPutting ? 0.9 : 0.7;
  return clamp(0.5 + clamp(dy*k, -0.30, 0.30), 0.10, 0.90);
}
function loftFactor(clubId){
  return {
    driver:0.15, wood3:0.22, drivingIr:0.28,
    iron5:0.35, iron6:0.42, iron8:0.55,
    pw:0.65, lw60:0.75, putter:0.02
  }[clubId] ?? 0.30;
}
const CLUB_REASSURE = {
  driver:"Okay, let it rip.",
  drivingIr:"Fairway finder locked.",
  wood3:"Big carry, smooth tempo.",
  iron5:"Smart layup. Plotting the path.",
  iron6:"Thread the needle time.",
  iron8:"Cozy swing incoming.",
  pw:"Feather it in.",
  lw60:"Float and land soft.",
  putter:"Walk it in."
};
const REMARKS = {
  fairway:[
    "Center-cut. Smooth as butter.",
    "Stripe show. Keep strolling.",
    "Box office swing. We’re moving."
  ],
  rough:[
    "Fluffy lie. We’ll handle it.",
    "Bit leafy. Still very playable.",
    "Grass is longer, vibes still high."
  ],
  trees:[
    "Pine-scented detour. Creative golf unlocked.",
    "Found a window with your name on it.",
    "Forest networking session. We’re fine."
  ],
  sand:[
    "Beach break. Sunscreen optional.",
    "Bunker? More like sandbox for adults.",
    "Splash of sand. Up and down time."
  ],
  water:[
    "Hydrated the ball. Happens to legends.",
    "That one swims. Next one flies.",
    "Quick rinse. Reset and go."
  ],
  green:[
    "On the dance floor. Lead the waltz.",
    "Showtime. Eyes on the cup.",
    "Lovely pace. Let’s tidy up."
  ],
  cup:[
    "Walked it in. Chef’s kiss.",
    "Dead center. That’ll play.",
    "Called it and delivered."
  ]
};

/* ===== State ===== */
const STATE={ distYds:409,onGreen:false,distFt:0, shots:0,penalties:0,finished:false,pickedUp:false, path:[{x:0.05,y:0.60}], _history:[] };

const CLUBS={
  driver:{id:"driver",name:"The Big Dog",kind:"aggr",max:260,perf:0.10,anglePenalty:0.20,spdA:0.010,spdP:0.010,copy:"Let it fly."},
  drivingIr:{id:"drivingIr",name:"The Fairway Finder",kind:"safe",max:210,perf:0.30,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Short grass energy."},
  wood3:{id:"wood3",name:"The Long Shot",kind:"aggr",max:235,perf:0.12,anglePenalty:0.18,spdA:0.009,spdP:0.009,copy:"Get it dancing."},
  iron5:{id:"iron5",name:"The Layup",kind:"safe",max:190,perf:0.32,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Smart is sexy."},
  iron6:{id:"iron6",name:"The Nudge",kind:"aggr",max:170,perf:0.14,anglePenalty:0.16,spdA:0.008,spdP:0.008,copy:"Thread it."},
  iron8:{id:"iron8",name:"The Cozy One",kind:"safe",max:135,perf:0.34,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Pin-high vibes."},
  pw:{id:"pw",name:"The Flighted Wedge",kind:"aggr",max:115,perf:0.16,anglePenalty:0.14,spdA:0.008,spdP:0.007,copy:"Send it soft."},
  lw60:{id:"lw60",name:"The Float",kind:"safe",max:90,perf:0.36,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Up. Down. Close."},
  putter:{id:"putter",name:"Putter",kind:"putt",max:90,perf:0.55,anglePenalty:0,spdA:0,spdP:0.004,copy:"Walk it in."}
};

const COMMENTARY={ fairway:["Striped it.","Center-cut.","Rolling nice."], rough:["Found the long stuff, still playable.","Fluffy lie incoming."], trees:["Pine-cone collector.","90% air, 10% character."], water:["Nice day for a swim.","Splashy detour."], sand:["Beach break.","Sandy toes, steady pose."], green:["On the dance floor.","Showtime."], cup:["Walked it in.","Dead center."] };

const scene=$("#scene"); $("#pickupFloating").onclick=finishPickup;

function resetState(){ STATE.distYds=409; STATE.onGreen=false; STATE.distFt=0; STATE.shots=0; STATE.penalties=0; STATE.finished=false; STATE.pickedUp=false; STATE.path=[{x:0.05,y:0.60}]; STATE._history=[]; }

/* ===== Title & Leaderboard ===== */
function sceneTitle(){
  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:900px">
      <div class="badge">Bogey Hound · 18th · 409 yds</div>
      <h1>The sun is down,<br/>the vibes are up.<br/>Let’s walk it in.</h1>
      <p class="small">Power first. Angle second on full shots. Putts are single tap.</p>
      <div class="row"><button id="start">Start</button><button class="secondary" id="lb">Leaderboard</button></div>
    </div>`;
  $("#start").onclick=()=>{ resetState(); sceneClubSelect(); };
  $("#lb").onclick=sceneLeaderboard;
}
const LB_KEY="bh_walkin_lb_v7";
function loadLB(){ try{return JSON.parse(localStorage.getItem(LB_KEY)||"[]")}catch(e){return[]} }
function saveLB(i,s,tag){ const lb=loadLB(); lb.push({i,s,tag,t:Date.now()}); lb.sort((a,b)=>a.s-b.s||a.t-b.t); localStorage.setItem(LB_KEY,JSON.stringify(lb.slice(0,10))); }
function sceneLeaderboard(){
  const lb=loadLB();
  const rows = lb.map((r,i)=>`<tr><td>${i+1}</td><td>${r.i}</td><td>${r.s}</td><td>${r.tag||""}</td><td>${new Date(r.t).toLocaleDateString()}</td></tr>`).join("") || `<tr><td colspan="5" class="small">No scores yet.</td></tr>`;
  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:760px">
      <h2>Leaderboard</h2>
      <table class="leader" style="width:100%;border-collapse:collapse">
        <thead><tr><th>#</th><th>Initials</th><th>Score</th><th>Note</th><th>Date</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
      <div class="row"><button class="secondary" id="back">Back</button></div>
    </div>`;
  $("#back").onclick=sceneTitle;
}

/* ===== Minimap / Overhead ===== */
function drawMini(canvas, zoomGreen=false){
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const bb=canvas.getBoundingClientRect();
  canvas.width=Math.floor(bb.width*dpr); canvas.height=Math.floor(bb.height*dpr);
  const ctx=canvas.getContext("2d"); ctx.scale(dpr,dpr);

  // base
  ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);

  // Rough
  ctx.fillStyle=getCSS('--rough'); roundRect(ctx, bb.width*0.02, bb.height*0.34, bb.width*0.96, bb.height*0.44, 28, true);
  // Fairway
  ctx.fillStyle=getCSS('--fair'); roundRect(ctx, bb.width*0.06, bb.height*0.40, bb.width*0.88, bb.height*0.32, 26, true);

  // Pines up the left/top
  const pEndX = bb.width*(0.06 + 0.88*0.73);
  const topY = bb.height*0.40;
  ctx.fillStyle=getCSS('--tree');
  for(let x=bb.width*0.06; x<pEndX; x+=18){ drawPine(ctx, x, topY-6, 14, 22); }

  // Water
  const wStartX = bb.width*(0.06 + 0.88*0.49);
  ctx.fillStyle=getCSS('--water');
  ctx.beginPath();
  ctx.moveTo(wStartX, bb.height*0.72);
  ctx.quadraticCurveTo(bb.width*0.80, bb.height*0.86, bb.width*0.98, bb.height*0.82);
  ctx.lineTo(bb.width*0.98, bb.height*0.96);
  ctx.lineTo(wStartX, bb.height*0.96);
  ctx.closePath(); ctx.fill();

  // Fairway bunker
  const bx = bb.width*(0.06 + 0.88*(350/409));
  const by = bb.height*0.48;
  ctx.fillStyle=getCSS('--sand');
  ctx.beginPath(); ctx.ellipse(bx, by, bb.width*0.035, bb.height*0.04, 0, 0, Math.PI*2); ctx.fill();

  // Green + flag
  const greenCx = bb.width*0.90, greenCy = bb.height*0.56, greenRx = bb.width*0.08, greenRy = bb.height*0.06;
  ctx.fillStyle="#2f7a63"; ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();
  const holeX = greenCx+greenRx*0.28, holeY = greenCy;
  ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
  ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();

  // Trace path
  const pts = STATE.path.map(p=>({x:lerp(0,bb.width,p.x), y:lerp(0,bb.height,p.y)}));

  // Zoom on green when putting
  if(zoomGreen || STATE.onGreen){
    const pad=12, gx=greenCx-greenRx-pad, gy=greenCy-greenRy-pad, gw=greenRx*2+pad*2, gh=greenRy*2+pad*2;
    ctx.save(); ctx.clearRect(0,0,bb.width,bb.height); ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);
    const sx=bb.width/gw, sy=bb.height/gh, s=Math.min(sx,sy);
    ctx.translate(-gx*s,-gy*s); ctx.scale(s,s);
    ctx.fillStyle="#2f7a63"; ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="#fff"; ctx.lineWidth=2/s; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
    ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2/s; ctx.beginPath(); pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
    const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4/s,0,Math.PI*2); ctx.fill();
    ctx.restore(); return;
  }

  ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2; ctx.beginPath();
  pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
  const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4,0,Math.PI*2); ctx.fill();
}
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v); }
function roundRect(ctx,x,y,w,h,r,fill=true){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); fill?ctx.fill():ctx.stroke(); }
function drawPine(ctx,cx,baseY,w,h){
  ctx.fillStyle=getCSS('--tree');
  ctx.beginPath(); ctx.moveTo(cx, baseY-h); ctx.lineTo(cx-w*0.6, baseY-h*0.55); ctx.lineTo(cx+w*0.6, baseY-h*0.55); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx, baseY-h*0.55); ctx.lineTo(cx-w*0.8, baseY-h*0.15); ctx.lineTo(cx+w*0.8, baseY-h*0.15); ctx.closePath(); ctx.fill();
  ctx.fillRect(cx-2, baseY-h*0.15, 4, h*0.15);
}

/* ===== Club selection ===== */
function clubOptionsByDist(){
  const d=STATE.distYds;
  if(STATE.onGreen) return [{key:"putter",data:CLUBS.putter}];
  if(d>190) return [{key:"driver",data:CLUBS.driver},{key:"drivingIr",data:CLUBS.drivingIr}];
  if(d>120) return [{key:"wood3",data:CLUBS.wood3},{key:"iron5",data:CLUBS.iron5}];
  if(d>60)  return [{key:"iron6",data:CLUBS.iron6},{key:"iron8",data:CLUBS.iron8}];
  return [{key:"pw",data:CLUBS.pw},{key:"lw60",data:CLUBS.lw60}];
}
function sceneClubSelect(){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen);

  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const card=document.createElement("div"); card.className="card stack"; card.style.padding="18px";
  card.innerHTML=`
    <div class="hud">
      <div class="pill">${STATE.onGreen?"Putt":"Pick your pace"}</div>
      <div class="pill">Distance: ${distLabel}</div>
      <div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>
    </div>
    <div class="row" id="clubRow"></div>
    <div class="small">Tip: Power, then angle on full shots. On the green, it’s one tap.</div>
  `;
  wrap.appendChild(card);

  const row=$("#clubRow",card);
  clubOptionsByDist().forEach(({key,data})=>{
    const c=document.createElement("div"); c.className="card stack"; c.style.padding="16px"; c.style.flex="1 1 260px";
    c.innerHTML=`
      <div class="badge">${data.kind==="putt"?"PUTT":(data.kind==="aggr"?"Aggressive":"Safe")}</div>
      <h2>${data.name}</h2>
      <div class="small">${data.copy}</div>
      <div class="row"><div class="pill">Max ${STATE.onGreen?Math.round(data.max)+" ft":Math.round(data.max)+" yds"}</div><div class="pill">Perfect ~${Math.round(data.perf*100)}%</div></div>
      <button>Use ${data.name}</button>`;
    $("button",c).onclick=async()=>{
      const msg = CLUB_REASSURE[data.id] || "Good swing. Let’s go.";
      await typeToast(msg, 20, 600);
      sceneSwingPowerFirst(key,data);
    };
    row.appendChild(c);
  });
}

/* ===== Swing: POWER → ANGLE (auto-hit ; putts = single tap) ===== */
function sceneSwingPowerFirst(key, club){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen); // zooms on green

  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const header=document.createElement("div"); header.className="hud";
  header.innerHTML=`<div class="pill">1/1${STATE.onGreen?"":" of 2"} – POWER · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  wrap.appendChild(header);

  // POWER meter
  const box=document.createElement("div"); box.className="meter";
  box.innerHTML=`<canvas id="power"></canvas><div class="overlay"><div class="readout" id="powLabel">0</div></div>`;
  wrap.appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  const angleStep = !(STATE.onGreen || club.kind==="putt");
  ctrls.innerHTML=`<button class="secondary" id="back">Back</button><button id="toggleP">Pause</button><button id="lockP" class="danger">Lock Power</button>`;
  wrap.appendChild(ctrls);

  $("#back").onclick=sceneClubSelect;

  const pCVS=$("#power"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(pCVS);

  let cursorP=0, dirP=1, raf, paused=false;
  const spdP=club.spdP;

  function requiredPower(){
    if(STATE.onGreen){ return clamp(STATE.distFt / club.max, 0, 1); }
    let lie=1; const prev=lastOutcome();
    if(prev===OUT.TREES) lie=0.5; else if(prev===OUT.ROUGH_L||prev===OUT.ROUGH_R||prev===OUT.SAND) lie=0.9;
    const needed=Math.max(1,STATE.distYds), effMax=club.max*lie;
    return Math.min(1, needed/Math.max(1,effMax));
  }
  function idealBandWidth(){
    if(STATE.onGreen){
      const ft = STATE.distFt;
      if(ft<=6)  return 0.55;
      if(ft<=12) return 0.42;
      if(ft<=20) return 0.34;
      if(ft<=30) return 0.28;
      if(ft<=50) return 0.23;
      return 0.20;
    }
    return (club.kind==="safe"?0.34:0.18);
  }

  function drawPower(){
    const bb=pCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);
    ctx.fillStyle="rgba(255,255,255,.09)"; ctx.fillRect(bb.width*.08, bb.height*.12, bb.width*.84, bb.height*.76);
    const ideal=requiredPower(), band=idealBandWidth();
    const ph=bb.height*.76*band, cyIdeal=bb.height*.88 - (bb.height*.76)*ideal, py=clamp(cyIdeal - ph/2, bb.height*.12, bb.height*.88-ph);
    ctx.fillStyle="rgba(212,61,61,.32)"; ctx.fillRect(bb.width*.08, py, bb.width*.84, ph);
    const cy = bb.height*.88 - cursorP*(bb.height*.76);
    ctx.fillStyle="#fff"; ctx.fillRect(bb.width*.50-10, cy-10, 20, 20);
    const unit = STATE.onGreen? "ft" : "yds"; const maxMark = club.max; const current = Math.round(maxMark*cursorP);
    $("#powLabel").textContent = current+" "+unit;
  }
  function tick(){ if(!paused){ cursorP+=spdP*dirP; if(cursorP>1){cursorP=1;dirP=-1} if(cursorP<0){cursorP=0;dirP=1} } drawPower(); raf=requestAnimationFrame(tick); }
  tick();

  pCVS.addEventListener("click", ()=> lockPower(cursorP));
  $("#lockP").onclick=()=>lockPower(cursorP);
  $("#toggleP").onclick=()=>{ paused=!paused; $("#toggleP").textContent=paused?"Resume":"Pause"; };
  window.addEventListener("keydown", e=>{ if(e.code==="Space"){ e.preventDefault(); lockPower(cursorP);} });

  function lockPower(val){
    cancelAnimationFrame(raf);
    const p = clamp(val,0,1);
    if(angleStep){ sceneSwingAngleSecond(key, club, p); }
    else{
      // Single-tap putt: feed ideal angle internally
      const ideal = idealAngleCenter(true);
      resolveSwing(club, ideal, p);
    }
  }
}

function sceneSwingAngleSecond(key, club, powerVal){
  scene.innerHTML="";
  const wrap=document.createElement("div"); wrap.className="stack"; wrap.style.maxWidth="960px";

  const mini=document.createElement("div"); mini.className="mini"; mini.innerHTML=`<canvas id="mini"></canvas>`;
  wrap.appendChild(mini); scene.appendChild(wrap);
  drawMini($("#mini"), STATE.onGreen);

  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const header=document.createElement("div"); header.className="hud";
  header.innerHTML=`<div class="pill">2/2 – ANGLE · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  wrap.appendChild(header);

  const box=document.createElement("div"); box.className="meter";
  box.innerHTML=`<canvas id="angle"></canvas>`;
  wrap.appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  ctrls.innerHTML=`<button class="secondary" id="back">Back</button><button id="toggleA">Pause</button><button id="lockA" class="danger">Lock Angle</button>`;
  wrap.appendChild(ctrls);

  $("#back").onclick=sceneClubSelect;

  const aCVS=$("#angle"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(aCVS);

  let cursorA=0.5, dirA=1, raf, paused=false;
  const spdA=club.spdA;

  const isPutting = STATE.onGreen || club.kind==="putt";
  const idealC = idealAngleCenter(isPutting);
  const windowNorm = isPutting ? puttLineWindow(STATE.distFt) : club.perf;

  function drawAngle(){
    const bb=aCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);
    // track
    ctx.fillStyle="rgba(255,255,255,.09)";
    ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84, bb.height*.08);
    // ideal band (shifted toward hole)
    const pw = bb.width*.84 * windowNorm;
    const px = bb.width*.08 + bb.width*.84*idealC - pw/2;
    ctx.fillStyle="rgba(212,61,61,.32)";
    ctx.fillRect(px, bb.height*.46, pw, bb.height*.08);
    // danger edges for non-putts
    if(!isPutting && club.anglePenalty>0){
      ctx.fillStyle="rgba(255,255,255,.16)";
      ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
      ctx.fillRect(bb.width*(.92 - .84*club.anglePenalty), bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
    }
    // cursor
    const cx = bb.width*.08 + cursorA*bb.width*.84;
    ctx.fillStyle="#fff"; ctx.fillRect(cx-10, bb.height*.42, 20, bb.height*.16);
  }
  function tick(){ if(!paused){ cursorA+=spdA*dirA; if(cursorA>1){cursorA=1;dirA=-1} if(cursorA<0){cursorA=0;dirA=1} } drawAngle(); raf=requestAnimationFrame(tick); }
  tick();

  aCVS.addEventListener("click", ()=>lockAngle(cursorA));
  $("#lockA").onclick=()=>lockAngle(cursorA);
  $("#toggleA").onclick=()=>{ paused=!paused; $("#toggleA").textContent=paused?"Resume":"Pause"; };
  window.addEventListener("keydown", e=>{ if(e.code==="Enter"){ e.preventDefault(); lockAngle(cursorA);} });

  function lockAngle(val){
    cancelAnimationFrame(raf);
    STATE._puttIdealCenter = idealC;
    STATE._puttWindowNorm  = windowNorm;
    resolveSwing(club, clamp(val,0,1), powerVal);
  }
}

/* ===== Outcome logic + animations ===== */
const OUT={ TREES:"trees", ROUGH_L:"roughL", FAIRWAY:"fairway", ROUGH_R:"roughR", WATER:"water", SAND:"sand", GREEN:"green", CUP:"cup" };
function lastOutcome(){ const h=STATE._history; return h.length? h[h.length-1].outcome : null; }

function computeToByCarry(from, progress, lateral){
  return {
    x: clamp(from.x + progress*0.82, 0.04, 0.97),
    y: clamp(from.y + lateral*0.60, 0.18, 0.82)
  };
}
function computeToTowardHole(from, frac){
  return { x: lerp(from.x, HOLE.x, frac), y: lerp(from.y, HOLE.y, frac) };
}

async function animateArcOnMini(from, to, isPutt, clubId){
  const cv=$("#mini"); if(!cv) return;
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const bb=cv.getBoundingClientRect(); const width=bb.width; const height=bb.height;
  // duration
  const dist = Math.hypot((to.x-from.x),(to.y-from.y)); // normalized
  let dur = isPutt ? Math.max(PACE.puttFlightMin, PACE.flightBase*0.7 + PACE.flightPerUnit*dist*0.5)
                   : (PACE.flightBase + PACE.flightPerUnit*dist);
  // arc height (normalized)
  const loft = loftFactor(clubId);
  const arc = isPutt ? 0.00 : clamp(loft * Math.max(0.12, dist*0.6), 0.05, 0.28);

  const start = performance.now();
  const idx = STATE.path.length-1;           // last point will be animated
  const orig = {x:STATE.path[idx].x, y:STATE.path[idx].y};
  function bezier(t,a,b,c){ return (1-t)*(1-t)*a + 2*(1-t)*t*b + t*t*c; }

  while(true){
    const now=performance.now();
    let t = clamp((now-start)/dur, 0, 1);
    // Ease in-out
    t = t<0.5 ? 2*t*t : -1+(4-2*t)*t;

    const midx = (from.x+to.x)/2, midy = (from.y+to.y)/2 - arc;
    const cx = bezier(t, from.x, midx, to.x);
    const cy = bezier(t, from.y, midy, to.y);

    STATE.path[idx] = {x:cx, y:cy};
    drawMini(cv, STATE.onGreen); // respect zoom on green
    if((now-start)>=dur) break;
    await sleep(16);
  }
  STATE.path[idx] = {x:to.x, y:to.y};
  drawMini(cv, STATE.onGreen);
}

async function resolveSwing(club, angle, power){
  STATE.shots++;

  // ===== Putting: single-tap power =====
  if(club.kind==="putt" || STATE.onGreen){
    STATE.onGreen=true;

    const target = Math.max(1, STATE.distFt || 0);        // feet to hole
    const hitFt  = clamp(power*club.max, 0, club.max);    // how far you sent it
    const tolFt  = puttPowerTolerance(target);

    // Only pace matters (single tap). Smooth and intuitive.
    const qPower = clamp(1 - Math.abs(hitFt - target)/tolFt, 0, 1);
    const baseP  = pgaMakeProb(target);
    const pMake  = clamp(baseP * qPower, 0, 1);
    const made   = Math.random() < pMake;

    const from = STATE.path[STATE.path.length-1];
    // Where the roll ends (for made: the cup; for miss: toward the cup by fraction)
    if(made){
      // Animate to cup
      STATE.path.push({x:from.x, y:from.y});
      await animateArcOnMini(from, {x:HOLE.x,y:HOLE.y}, true, 'putter');
      pushHistory(OUT.CUP, club.name); SFX.cup.play();
      await typeToast(choice(REMARKS.cup), 18, 700);
      return finishRound();
    } else {
      const frac = clamp(hitFt / Math.max(1,target), 0.05, 0.98);
      const to = computeToTowardHole(from, frac);
      STATE.path.push({x:from.x, y:from.y});
      await animateArcOnMini(from, to, true, 'putter');

      // Remaining leave with a little wiggle so misses look natural
      const leave = Math.max(1, Math.abs(hitFt - target) + 1.2);
      STATE.distFt = leave;
      pushHistory(OUT.GREEN, club.name);
      await typeToast(choice(REMARKS.green), 18, 700);
      await sleep(PACE.betweenShots);
      return sceneClubSelect();
    }
  }

  // ===== Full shot =====
  let lie=1; const prev=lastOutcome();
  if(prev===OUT.TREES) lie=0.5;
  else if(prev===OUT.ROUGH_L||prev===OUT.ROUGH_R||prev===OUT.SAND) lie=0.9;

  const effMax=club.max*lie;
  let carry = clamp(power*effMax, 10, effMax);
  const before=STATE.distYds;
  let after=Math.max(0, before - carry);

  const lateral = angle - 0.5;
  let outcome = OUT.FAIRWAY;

  // Hazards thresholds from tee:
  const TREES_ACTIVE = before >= 109;
  const WATER_ACTIVE = before >= 209;

  if(TREES_ACTIVE && (angle < club.anglePenalty) && lateral<0){ outcome = OUT.TREES; }
  if(WATER_ACTIVE && (angle > 1 - club.anglePenalty) && lateral>0){ outcome = OUT.WATER; }

  // Fairway bunker logic
  if(outcome===OUT.FAIRWAY && after<=80 && after>=40 && lateral < -0.08){
    outcome = OUT.SAND;
  }

  // Near green classification
  if(after<=60 && outcome===OUT.FAIRWAY){
    if(lateral<-0.10) outcome=OUT.SAND;
    else if(Math.abs(lateral)<=0.18) outcome=OUT.GREEN;
    else outcome=(lateral<0)? OUT.ROUGH_L : OUT.ROUGH_R;
  } else if(outcome===OUT.FAIRWAY){
    if(Math.abs(lateral)<=0.18) outcome=OUT.FAIRWAY;
    else outcome=(lateral<0)? OUT.ROUGH_L : OUT.ROUGH_R;
  }

  if(outcome===OUT.WATER){
    STATE.penalties++; SFX.splash.play();
    outcome=OUT.ROUGH_R; // drop right rough
  }

  // Update distances
  if(outcome===OUT.GREEN){
    STATE.onGreen=true; STATE.distFt=Math.max(3, Math.round(after*3));
  } else {
    STATE.onGreen=false; STATE.distYds=Math.max(1, after);
  }

  // Compute target point, animate along an arc, then remark and continue
  const from = STATE.path[STATE.path.length-1];
  const to   = computeToByCarry(from, carry/before, lateral);
  STATE.path.push({x:from.x, y:from.y});                              // add animated point
  await animateArcOnMini(from, to, false, club.id);

  let line="";
  if(outcome===OUT.FAIRWAY) line=choice(REMARKS.fairway);
  else if(outcome===OUT.ROUGH_L||outcome===OUT.ROUGH_R) line=choice(REMARKS.rough);
  else if(outcome===OUT.TREES) line=choice(REMARKS.trees);
  else if(outcome===OUT.SAND) line=choice(REMARKS.sand);
  else if(outcome===OUT.GREEN) line=choice(REMARKS.green);
  else line="Nice move. Keep walking.";

  pushHistory(outcome, club.name);
  await typeToast(line, 18, 700);
  await sleep(PACE.betweenShots);
  sceneClubSelect();
}

/* ===== Path & History ===== */
function pushHistory(outcome,club){ STATE._history.push({outcome,club,shots:STATE.shots,pen:STATE.penalties,onGreen:STATE.onGreen,distYds:STATE.distYds,distFt:STATE.distFt}); }

/* ===== Finish & Pick-up ===== */
function finishRound(){ const strokes=STATE.shots+STATE.penalties; finishScreen(strokes, null); }
async function finishPickup(){ const par=4, minScore=par+2; STATE.pickedUp=true; const strokes=Math.max(STATE.shots+STATE.penalties, minScore); await typeToast("Pocket the ball. Fresh start.",18,700); finishScreen(strokes, "Picked up"); }
function finishScreen(strokes, tag){
  STATE.finished=true; const par=4, diff=strokes-par;
  const label = tag?tag:(diff<=-2?"Eagle":diff===-1?"Birdie":diff===0?"Par":diff===1?"Bogey":"+ "+diff);
  scene.innerHTML=`
    <div class="card stack" style="padding:22px;max-width:900px">
      <div class="badge">Final</div>
      <h2>${strokes} • ${label}</h2>
      <div class="row"><div class="pill">Shots: ${STATE.shots}</div><div class="pill">Penalties: ${STATE.penalties}</div></div>
      <div class="row">
        <button id="again">Restart</button>
        <button class="secondary" id="store">Visit the store</button>
        <button class="ghost" id="lb">Leaderboard</button>
      </div>
      <div class="row">
        <input id="init" maxlength="3" placeholder="ABC" style="padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.2);color:var(--cream)">
        <button id="save">Save Score</button>
      </div>
      <div id="msg" class="small"></div>
    </div>`;
  $("#again").onclick=sceneTitle;
  $("#store").onclick=()=>location.href="https://bogeyhound.com";
  $("#lb").onclick=sceneLeaderboard;
  $("#save").onclick=()=>{ const i=($("#init").value||"__").toUpperCase().replace(/[^A-Z]/g,"").slice(0,3).padEnd(3,"_"); saveLB(i,strokes, tag||""); $("#msg").textContent="Saved."; };
}

/* ===== Boot ===== */
sceneTitle();
</script>
</body>
</html>

