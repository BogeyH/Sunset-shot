<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bogey Hound – The Walk In</title>
<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>
<style>
:root{
  --navy:#0B1F2A; --cream:#FDF0D5; --red:#C1121F;
  --rough:#2a4a3f; --fair:#2f6a58; --water:#1e587a; --sand:#d8c3a5; --tree:#163d33;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--navy);color:var(--cream);font-family:"Space Grotesk",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;overflow:hidden}

/* Hero background image */
#heroBG{
  position:fixed; inset:0; object-fit:cover; width:100%; height:100%; z-index:-2;
  background:linear-gradient(180deg,#522d16, #0B1F2A);
}

/* Bottom course map (always present once game starts) */
#miniWrap{position:fixed; left:0; right:0; bottom:0; height:220px; z-index:1; display:none}
.mini{width:100%;height:100%;border-radius:12px 12px 0 0;background:#0e2a26;border-top:1px solid rgba(255,255,255,.14);overflow:hidden}
.mini canvas{width:100%;height:100%}

/* Center overlay box (start screen) */
#startOverlay{
  position:fixed; inset:0; display:grid; place-items:center; z-index:3;
  background:linear-gradient(0deg, rgba(0,0,0,.35), rgba(0,0,0,.15));
}
.card{background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.16);backdrop-filter:blur(8px);border-radius:18px;box-shadow:0 20px 60px rgba(0,0,0,.4)}
.stack{display:flex;flex-direction:column;gap:14px}
.row{display:flex;gap:12px;flex-wrap:wrap}
button{font:600 16px "Space Grotesk";padding:12px 16px;border-radius:14px;border:0;background:var(--cream);color:var(--navy);cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,.25)}
button.secondary{background:transparent;color:var(--cream);border:2px solid rgba(253,240,213,.5)}
button.danger{background:#f25757;color:white}

/* Main scene (UI sits here) */
#scene{position:fixed; inset:0 0 220px 0; padding:16px; overflow:auto; z-index:2}

/* Top typed header */
#typeHeader{
  position:sticky; top:0; left:0; right:0; padding:8px 4px 18px;
  font-family:"Libre Baskerville",serif; font-weight:700; color:var(--navy);
  text-shadow:0 3px 18px rgba(255,255,255,.35);
  font-size: clamp(26px, 6vw, 56px); line-height:1.1;
}

/* Club select panel */
.panel{padding:18px;border-radius:18px}
.pill{padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.18);font-weight:600}
.small{opacity:.88;font-size:12px}

/* Meters */
.meter{height:160px;border-radius:16px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden}
.meter canvas{width:100%;height:100%}
.meter .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
.readout{font:800 28px "Space Grotesk";background:rgba(0,0,0,.35);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.18)}

/* Central remarks (word-by-word typing) */
#remark{
  position:fixed; inset:auto 8% 50% 8%; transform:translateY(50%); text-align:center;
  font:700 clamp(18px,3.2vw,28px) "Space Grotesk";
  padding:14px 18px; border-radius:14px;
  background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.18);
  backdrop-filter:blur(6px); z-index:4; display:none;
}

/* Pick up */
#pickupFloating{
  position:fixed; left:12px; bottom:232px; z-index:5;
  padding:10px 14px; border-radius:12px; background:rgba(0,0,0,.4);
  border:1px solid rgba(255,255,255,.2); color:var(--cream); font-weight:700;
  backdrop-filter:blur(6px); display:none;
}
#pickupFloating:hover{background:rgba(0,0,0,.55)}
</style>
</head>
<body>

<!-- Fullscreen hero image (replace src with your art if you like) -->
<img id="heroBG" alt="Sunset golf art" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Sunset_Golf_Illustration.png/1024px-Sunset_Golf_Illustration.png" />

<!-- Start overlay (only visible at boot) -->
<div id="startOverlay">
  <div class="card stack panel" style="padding:22px;max-width:520px;text-align:center">
    <div style="font:700 20px 'Space Grotesk'">Bogey Hound · The Walk In</div>
    <div class="row" style="justify-content:center">
      <button id="btnStart">Start game</button>
      <button class="secondary" id="btnLB">Check the leaderboard</button>
    </div>
  </div>
</div>

<!-- Main scene area -->
<main id="scene">
  <div id="typeHeader"></div>
  <!-- dynamic UI goes here -->
</main>

<!-- Central slow-typed remarks -->
<div id="remark"></div>

<!-- Course map fixed to bottom -->
<div id="miniWrap"><div class="mini"><canvas id="mini"></canvas></div></div>

<!-- Always-visible Pick Up once game begins -->
<button id="pickupFloating" title="End the hole now">Pick up</button>

<script>
/* ===== Audio stubs ===== */
const SFX = { hit:new Howl({src:[],volume:.5}), splash:new Howl({src:[],volume:.5}), sand:new Howl({src:[],volume:.5}), cup:new Howl({src:[],volume:.6}) };

/* ===== DOM helpers ===== */
const $=(s,r=document)=>r.querySelector(s);
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const choice=a=>a[Math.floor(Math.random()*a.length)];
const lerp=(a,b,t)=>a+(b-a)*t;
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

/* ===== Pace & vibes ===== */
const PACE = {
  betweenShots: 1200,
  flightBase: 900,
  flightPerUnit: 2100,
  puttFlightMin: 520,
  remarkHold: 4000,
  wordMs: 160,
  letterMs: 26
};

/* ===== Typing helpers ===== */
async function typeHeaderLines(lines){
  const el=$("#typeHeader"); el.textContent=""; el.style.color="var(--navy)";
  for(const line of lines){
    let buf=""; 
    for(const ch of line){ buf+=ch; el.textContent=buf; await sleep(PACE.letterMs); }
    await sleep(420);
    el.innerHTML += "<br/>";
  }
}
async function typeRemark(txt){
  const el=$("#remark"); el.textContent=""; el.style.display="block";
  const words = txt.split(/\s+/);
  for(let i=0;i<words.length;i++){
    el.textContent += (i? " ":"") + words[i];
    await sleep(PACE.wordMs);
  }
  await sleep(PACE.remarkHold);
  el.style.display="none";
}

/* ===== Constants & helpers for play ===== */
const HOLE = { x:0.97, y:0.56 };

function loftFactor(clubId){
  return { driver:0.15, wood3:0.22, drivingIr:0.26, iron5:0.35, iron6:0.44, iron8:0.58, pw:0.66, lw60:0.78, putter:0.02 }[clubId] ?? 0.30;
}

// “Pro-ish” baseline (still used if outside auto-make funnel)
function pgaMakeProb(ft){
  const T = [[1,0.995],[2,0.990],[3,0.970],[4,0.910],[5,0.820],[6,0.730],[7,0.640],[8,0.570],[9,0.520],[10,0.440],[12,0.350],[15,0.300],[20,0.200],[25,0.150],[30,0.100],[40,0.060]];
  if(ft<=1) return 0.995; if(ft>=40) return 0.06;
  for(let i=0;i<T.length-1;i++){ const [x1,y1]=T[i],[x2,y2]=T[i+1]; if(ft>=x1&&ft<=x2){ const t=(ft-x1)/(x2-x1); return y1+(y2-y1)*t; } }
  return 0.12;
}

// Wide “cup” logic for single-tap putting.
// - Hole is effectively 5 ft wide (angle-free game ⇒ we use generous pace band).
// - Any putt up to +7 ft long still falls (back-of-cup).
function puttAutoMake(hitFt, targetFt){
  const shortBand = (targetFt<=6) ? Math.max(1.5, targetFt*0.50)
                   : (targetFt<=12)? 3.5
                   : (targetFt<=20)? 4.0
                   : 5.0;
  const shortOK = hitFt >= Math.max(0, targetFt - shortBand);
  const longOK  = hitFt <= targetFt + 7;
  return shortOK && longOK;
}

/* ===== State ===== */
const STATE={ distYds:409,onGreen:false,distFt:0, shots:0,penalties:0,finished:false,pickedUp:false, path:[{x:0.05,y:0.60}], _history:[] };

const CLUBS={
  driver:{id:"driver",name:"The Big Dog",kind:"aggr",max:260,perf:0.10,anglePenalty:0.20,spdA:0.010,spdP:0.010,copy:"Let it fly."},
  drivingIr:{id:"drivingIr",name:"The Fairway Finder",kind:"safe",max:210,perf:0.30,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Short grass energy."},
  wood3:{id:"wood3",name:"The Long Shot",kind:"aggr",max:235,perf:0.12,anglePenalty:0.18,spdA:0.009,spdP:0.009,copy:"Get it dancing."},
  iron5:{id:"iron5",name:"The Layup",kind:"safe",max:185,perf:0.32,anglePenalty:0.01,spdA:0.006,spdP:0.006,copy:"Smart is sexy."},
  iron6:{id:"iron6",name:"The Nudge",kind:"aggr",max:165,perf:0.14,anglePenalty:0.16,spdA:0.008,spdP:0.008,copy:"Thread it."},
  iron8:{id:"iron8",name:"The Cozy One",kind:"safe",max:125,perf:0.34,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Pin-high vibes."},
  pw:{id:"pw",name:"The Flighted Wedge",kind:"aggr",max:95,perf:0.16,anglePenalty:0.14,spdA:0.008,spdP:0.007,copy:"Send it soft."},
  lw60:{id:"lw60",name:"The Float",kind:"safe",max:70,perf:0.36,anglePenalty:0.01,spdA:0.005,spdP:0.005,copy:"Up. Down. Close."},
  putter:{id:"putter",name:"Putter",kind:"putt",max:40,perf:0.70,anglePenalty:0,spdA:0,spdP:0.004,copy:"Walk it in."}
};

const CLUB_REASSURE = {
  driver:["Okay, let it rip.","Unleash the big dog.","Grip, rip, and smile."],
  drivingIr:["Fairway finder locked.","Boring golf is scoring golf.","Pilot light: steady."],
  wood3:["Big carry, smooth tempo.","Wide window. Send it.","Three-wood poetry."],
  iron5:["Smart layup. Plot the path.","Mid-iron meditation.","Balanced and brave."],
  iron6:["Thread the needle time.","Strong arc, soft land.","Flight it tidy."],
  iron8:["Cozy swing incoming.","Just a nudge and a hop.","One hop, stop."],
  pw:["Feather it in.","Crisp and quiet.","Clip it close."],
  lw60:["Float and land soft.","High, soft, delightful.","Butter knife from the clouds."],
  putter:["Walk it in.","Soft eyes, quiet hands.","Pace first, cup second."]
};

const REMARKS = {
  fairway:["Center-cut. Smooth as butter.","Stripe show. Keep strolling.","Box-office swing. We’re moving.","Glide path engaged.","High launch, low stress."],
  rough:["Fluffy lie. We’ll handle it.","Bit leafy. Still playable.","Grass is longer, vibes still high.","We’ve got options in here.","Wild side walk—no fear."],
  trees:["Pine-scented detour. Creative golf unlocked.","Found a window with your name on it.","Forest networking session. We’re fine.","Branches tried, rhythm survived.","Plot twist: arboreal edition."],
  sand:["Beach break. Sunscreen optional.","Bunker? Sandbox for adults.","Splash of sand. Up and down time.","Rake ready. Hands soft.","Nice postcard. Let’s get out."],
  water:["Hydrated the ball. Happens to legends.","That one swims. Next one flies.","Quick rinse. Reset and go.","Tiny vacation. Back to work.","We baptize, then birdie."],
  green:["On the dance floor. Lead the waltz.","Showtime. Eyes on the cup.","Lovely pace. Let’s tidy up.","Perfect invite to a two-step.","Roll it like a lullaby."],
  cup:["Walked it in. Chef’s kiss.","Dead center. That’ll play.","Called it and delivered.","No doubter. Pocket the coin.","Pure. Keep strolling."]
};

/* ===== Boot UI (start overlay only) ===== */
const scene=$("#scene");
const miniWrap=$("#miniWrap");
const miniCanvas=$("#mini");
const pickUp=$("#pickupFloating");

$("#btnLB").onclick=sceneLeaderboard;
$("#btnStart").onclick=async ()=>{ 
  $("#startOverlay").style.display="none";
  miniWrap.style.display="block";
  pickUp.style.display="block";
  await typeHeaderLines(["Sun’s down.","Vibes are up.","Let’s walk it in."]);
  await sleep(300);
  resetState(); sceneClubSelect();
};

pickUp.onclick=finishPickup;

/* ===== Minimap drawing ===== */
function drawMini(canvas, zoomGreen=false){
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const bb=canvas.getBoundingClientRect();
  canvas.width=Math.floor(bb.width*dpr); canvas.height=Math.floor(bb.height*dpr);
  const ctx=canvas.getContext("2d"); ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);

  ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);

  // base shapes
  ctx.fillStyle=getCSS('--rough'); roundRect(ctx, bb.width*0.02, bb.height*0.34, bb.width*0.96, bb.height*0.44, 28, true);
  ctx.fillStyle=getCSS('--fair');  roundRect(ctx, bb.width*0.06, bb.height*0.40, bb.width*0.88, bb.height*0.32, 26, true);

  // pines
  const pEndX = bb.width*(0.06 + 0.88*0.73);
  const topY = bb.height*0.40;
  ctx.fillStyle=getCSS('--tree');
  for(let x=bb.width*0.06; x<pEndX; x+=18){ drawPine(ctx, x, topY-6, 14, 22); }

  // water
  const wStartX = bb.width*(0.06 + 0.88*0.49);
  ctx.fillStyle=getCSS('--water'); ctx.beginPath();
  ctx.moveTo(wStartX, bb.height*0.72);
  ctx.quadraticCurveTo(bb.width*0.80, bb.height*0.86, bb.width*0.98, bb.height*0.82);
  ctx.lineTo(bb.width*0.98, bb.height*0.96);
  ctx.lineTo(wStartX, bb.height*0.96);
  ctx.closePath(); ctx.fill();

  // bunker
  const bx = bb.width*(0.06 + 0.88*(350/409));
  const by = bb.height*0.48;
  ctx.fillStyle=getCSS('--sand');
  ctx.beginPath(); ctx.ellipse(bx, by, bb.width*0.035, bb.height*0.04, 0, 0, Math.PI*2); ctx.fill();

  // green + flag
  const greenCx = bb.width*0.90, greenCy = bb.height*0.56, greenRx = bb.width*0.08, greenRy = bb.height*0.06;
  ctx.fillStyle="#2f7a63"; ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();
  const holeX = greenCx+greenRx*0.28, holeY = greenCy;
  ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
  ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();

  // Path trace
  const pts = STATE.path.map(p=>({x:lerp(0,bb.width,p.x), y:lerp(0,bb.height,p.y)}));

  if(zoomGreen || STATE.onGreen){
    const pad=12, gx=greenCx-greenRx-pad, gy=greenCy-greenRy-pad, gw=greenRx*2+pad*2, gh=greenRy*2+pad*2;
    ctx.save(); ctx.clearRect(0,0,bb.width,bb.height); ctx.fillStyle="#0e2a26"; ctx.fillRect(0,0,bb.width,bb.height);
    const sx=bb.width/gw, sy=bb.height/gh, s=Math.min(sx,sy);
    ctx.translate(-gx*s,-gy*s); ctx.scale(s,s);
    ctx.fillStyle="#2f7a63"; ctx.beginPath(); ctx.ellipse(greenCx, greenCy, greenRx, greenRy, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="#fff"; ctx.lineWidth=2/s; ctx.beginPath(); ctx.moveTo(holeX, holeY); ctx.lineTo(holeX, holeY-24); ctx.stroke();
    ctx.fillStyle=getCSS('--red'); ctx.beginPath(); ctx.moveTo(holeX, holeY-24); ctx.lineTo(holeX+16, holeY-18); ctx.lineTo(holeX, holeY-12); ctx.closePath(); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2/s; ctx.beginPath(); pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
    const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4/s,0,Math.PI*2); ctx.fill();
    ctx.restore(); return;
  }

  ctx.strokeStyle="rgba(255,255,255,.7)"; ctx.lineWidth=2; ctx.beginPath();
  pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke();
  const last=pts[pts.length-1]; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(last.x,last.y,4,0,Math.PI*2); ctx.fill();
}
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v); }
function roundRect(ctx,x,y,w,h,r,fill=true){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); fill?ctx.fill():ctx.stroke(); }
function drawPine(ctx,cx,baseY,w,h){
  ctx.fillStyle=getCSS('--tree');
  ctx.beginPath(); ctx.moveTo(cx, baseY-h); ctx.lineTo(cx-w*0.6, baseY-h*0.55); ctx.lineTo(cx+w*0.6, baseY-h*0.55); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx, baseY-h*0.55); ctx.lineTo(cx-w*0.8, baseY-h*0.15); ctx.lineTo(cx+w*0.8, baseY-h*0.15); ctx.closePath(); ctx.fill();
  ctx.fillRect(cx-2, baseY-h*0.15, 4, h*0.15);
}

/* ===== UI scenes ===== */
function resetState(){ STATE.distYds=409; STATE.onGreen=false; STATE.distFt=0; STATE.shots=0; STATE.penalties=0; STATE.finished=false; STATE.pickedUp=false; STATE.path=[{x:0.05,y:0.60}]; STATE._history=[]; drawMini(miniCanvas, false); }

const LB_KEY="bh_walkin_lb_v8";
function loadLB(){ try{return JSON.parse(localStorage.getItem(LB_KEY)||"[]")}catch(e){return[]} }
function saveLB(i,s,tag){ const lb=loadLB(); lb.push({i,s,tag,t:Date.now()}); lb.sort((a,b)=>a.s-b.s||a.t-b.t); localStorage.setItem(LB_KEY,JSON.stringify(lb.slice(0,10))); }

function sceneLeaderboard(){
  const lb=loadLB();
  const rows = lb.map((r,i)=>`<tr><td>${i+1}</td><td>${r.i}</td><td>${r.s}</td><td>${r.tag||""}</td><td>${new Date(r.t).toLocaleDateString()}</td></tr>`).join("") || `<tr><td colspan="5" class="small">No scores yet.</td></tr>`;
  const html=`
    <div class="card panel stack" style="padding:20px;max-width:760px;margin:40px auto">
      <h2 style="margin:0;font-family:'Libre Baskerville',serif">Leaderboard</h2>
      <table style="width:100%;border-collapse:collapse;margin-top:10px">
        <thead><tr><th>#</th><th>Initials</th><th>Score</th><th>Note</th><th>Date</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
      <div class="row" style="justify-content:flex-end"><button id="back">Back</button></div>
    </div>`;
  $("#scene").innerHTML = `<div id="typeHeader"></div>` + html;
  $("#back").onclick=()=>{ $("#scene").innerHTML=`<div id="typeHeader"></div>`; resetState(); sceneClubSelect(); };
}

function clubOptionsByDist(){
  const d=STATE.distYds; const firstShot=(STATE.shots===0 && !STATE.onGreen);
  if(STATE.onGreen) return [{key:"putter",data:CLUBS.putter}];

  // Driver & Fairway Finder only on first shot
  if(firstShot) return [{key:"driver",data:CLUBS.driver},{key:"drivingIr",data:CLUBS.drivingIr}];

  if(d>120) return [{key:"wood3",data:CLUBS.wood3},{key:"iron5",data:CLUBS.iron5}];
  if(d>60)  return [{key:"iron6",data:CLUBS.iron6},{key:"iron8",data:CLUBS.iron8}];
  return [{key:"pw",data:CLUBS.pw},{key:"lw60",data:CLUBS.lw60}];
}

function sceneClubSelect(){
  // header stays; fill rest with club panel
  const wrap=document.createElement("div"); wrap.className="card panel stack"; wrap.style.maxWidth="960px"; wrap.style.margin="8px auto";
  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;

  wrap.innerHTML=`
    <div class="row" style="justify-content:space-between">
      <div class="pill">${STATE.onGreen?"Putt":"Select your club"}</div>
      <div class="pill">Distance: ${distLabel}</div>
      <div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>
    </div>
    <div id="clubRow" class="row"></div>
    <div class="small">Tip: On the green it’s one tap. Off the green: power then angle.</div>
  `;
  $("#scene").appendChild(wrap);

  const row=$("#clubRow",wrap);
  clubOptionsByDist().forEach(({key,data})=>{
    const c=document.createElement("div"); c.className="card panel stack"; c.style.flex="1 1 260px";
    c.innerHTML=`
      <div class="pill">${data.kind==="putt"?"PUTT":(data.kind==="aggr"?"Aggressive":"Safe")}</div>
      <h3 style="margin:0">${data.name}</h3>
      <div class="small">${data.copy}</div>
      <div class="row"><div class="pill">Max ${STATE.onGreen?Math.round(data.max)+" ft":Math.round(data.max)+" yds"}</div><div class="pill">Perfect ~${Math.round(data.perf*100)}%</div></div>
      <button>Use ${data.name}</button>`;
    $("button",c).onclick=async()=>{
      const lines = CLUB_REASSURE[data.id] || ["Good swing. Let’s go."];
      await typeRemark(choice(lines));
      sceneSwingPowerFirst(key,data);
    };
    row.appendChild(c);
  });

  // keep map fresh
  drawMini(miniCanvas, STATE.onGreen);
}

/* ===== Swing: POWER (and ANGLE for full shots) ===== */
function sceneSwingPowerFirst(key, club){
  // clear below header
  $("#scene").innerHTML=`<div id="typeHeader"></div>`;
  const header=document.createElement("div");
  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  header.className="row"; header.style.justifyContent="space-between";
  header.innerHTML=`<div class="pill">1/${STATE.onGreen?1:2} – POWER · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  $("#scene").appendChild(header);

  const box=document.createElement("div"); box.className="meter"; box.innerHTML=`<canvas id="power"></canvas><div class="overlay"><div class="readout" id="powLabel">0</div></div>`;
  $("#scene").appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  ctrls.innerHTML=`<button id="back">Back</button><button id="toggleP" class="secondary">Pause</button><button id="lockP" class="danger">Lock Power</button>`;
  $("#scene").appendChild(ctrls);
  $("#back").onclick=()=>{ $("#scene").innerHTML=`<div id="typeHeader"></div>`; sceneClubSelect(); };

  const pCVS=$("#power"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(pCVS);

  let cursorP=0, dirP=1, raf, paused=false;
  const spdP=club.spdP;

  function requiredPower(){
    if(STATE.onGreen) return clamp(STATE.distFt / club.max, 0, 1);
    let lie=1; const prev=lastOutcome();
    if(prev===OUT.TREES) lie=0.5; else if(prev===OUT.ROUGH_L||prev===OUT.ROUGH_R||prev===OUT.SAND) lie=0.9;
    const needed=Math.max(1,STATE.distYds), effMax=club.max*lie;
    return Math.min(1, needed/Math.max(1,effMax));
  }
  function idealBandWidth(){
    if(STATE.onGreen){
      const ft = STATE.distFt;
      if(ft<=6)  return 0.65;
      if(ft<=12) return 0.50;
      if(ft<=20) return 0.42;
      if(ft<=30) return 0.34;
      return 0.28;
    }
    return (club.kind==="safe"?0.34:0.18);
  }
  function drawPower(){
    const bb=pCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);
    ctx.fillStyle="rgba(255,255,255,.09)"; ctx.fillRect(bb.width*.08, bb.height*.12, bb.width*.84, bb.height*.76);
    const ideal=requiredPower(), band=idealBandWidth();
    const ph=bb.height*.76*band, cyIdeal=bb.height*.88 - (bb.height*.76)*ideal, py=clamp(cyIdeal - ph/2, bb.height*.12, bb.height*.88-ph);
    ctx.fillStyle="rgba(212,61,61,.32)"; ctx.fillRect(bb.width*.08, py, bb.width*.84, ph);
    const cy = bb.height*.88 - cursorP*(bb.height*.76);
    ctx.fillStyle="#fff"; ctx.fillRect(bb.width*.50-10, cy-10, 20, 20);
    const unit = STATE.onGreen? "ft" : "yds"; const maxMark = club.max; const current = Math.round(maxMark*cursorP);
    $("#powLabel").textContent = current+" "+unit;
  }
  function tick(){ if(!paused){ cursorP+=spdP*dirP; if(cursorP>1){cursorP=1;dirP=-1} if(cursorP<0){cursorP=0;dirP=1} } drawPower(); raf=requestAnimationFrame(tick); }
  tick();

  pCVS.addEventListener("click", ()=> lockPower(cursorP));
  $("#lockP").onclick=()=>lockPower(cursorP);
  $("#toggleP").onclick=()=>{ paused=!paused; $("#toggleP").textContent=paused?"Resume":"Pause"; };
  window.onkeydown=e=>{ if(e.code==="Space"){ e.preventDefault(); lockPower(cursorP);} };

  function lockPower(val){
    cancelAnimationFrame(raf);
    const p = clamp(val,0,1);
    if(STATE.onGreen || club.kind==="putt"){
      // single-tap putt: feed ideal angle implicitly
      resolveSwing(club, 0.5, p);
    }else{
      sceneSwingAngleSecond(key, club, p);
    }
  }
}

function sceneSwingAngleSecond(key, club, powerVal){
  $("#scene").innerHTML=`<div id="typeHeader"></div>`;
  const distLabel = STATE.onGreen ? `${Math.round(STATE.distFt)} ft` : `${Math.round(STATE.distYds)} yds`;
  const header=document.createElement("div"); header.className="row"; header.style.justifyContent="space-between";
  header.innerHTML=`<div class="pill">2/2 – ANGLE · ${club.name}</div><div class="pill">Distance: ${distLabel}</div><div class="pill">Shots: ${STATE.shots} | Penalties: ${STATE.penalties}</div>`;
  $("#scene").appendChild(header);

  const box=document.createElement("div"); box.className="meter"; box.innerHTML=`<canvas id="angle"></canvas>`;
  $("#scene").appendChild(box);

  const ctrls=document.createElement("div"); ctrls.className="row";
  ctrls.innerHTML=`<button id="back">Back</button><button id="toggleA" class="secondary">Pause</button><button id="lockA" class="danger">Lock Angle</button>`;
  $("#scene").appendChild(ctrls);
  $("#back").onclick=()=>{ $("#scene").innerHTML=`<div id="typeHeader"></div>`; sceneClubSelect(); };

  const aCVS=$("#angle"); const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const fit=cv=>{ const bb=cv.getBoundingClientRect(); cv.width=Math.floor(bb.width*dpr); cv.height=Math.floor(bb.height*dpr); return cv.getContext("2d"); }
  const ctx=fit(aCVS);

  let cursorA=0.5, dirA=1, raf, paused=false;
  const spdA=club.spdA;

  const idealC = idealAngleCenter(false);
  const windowNorm = club.perf;

  function drawAngle(){
    const bb=aCVS.getBoundingClientRect();
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.clearRect(0,0,bb.width,bb.height);
    ctx.fillStyle="rgba(255,255,255,.09)";
    ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84, bb.height*.08);
    const pw = bb.width*.84 * windowNorm;
    const px = bb.width*.08 + bb.width*.84*idealC - pw/2;
    ctx.fillStyle="rgba(212,61,61,.32)";
    ctx.fillRect(px, bb.height*.46, pw, bb.height*.08);
    if(club.anglePenalty>0){
      ctx.fillStyle="rgba(255,255,255,.16)";
      ctx.fillRect(bb.width*.08, bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
      ctx.fillRect(bb.width*(.92 - .84*club.anglePenalty), bb.height*.46, bb.width*.84*club.anglePenalty, bb.height*.08);
    }
    const cx = bb.width*.08 + cursorA*bb.width*.84;
    ctx.fillStyle="#fff"; ctx.fillRect(cx-10, bb.height*.42, 20, bb.height*.16);
  }
  function tick(){ if(!paused){ cursorA+=spdA*dirA; if(cursorA>1){cursorA=1;dirA=-1} if(cursorA<0){cursorA=0;dirA=1} } drawAngle(); raf=requestAnimationFrame(tick); }
  tick();

  aCVS.addEventListener("click", ()=>lockAngle(cursorA));
  $("#lockA").onclick=()=>lockAngle(cursorA);
  $("#toggleA").onclick=()=>{ paused=!paused; $("#toggleA").textContent=paused?"Resume":"Pause"; };
  window.addEventListener("keydown", e=>{ if(e.code==="Enter"){ e.preventDefault(); lockAngle(cursorA);} });

  function lockAngle(val){
    cancelAnimationFrame(raf);
    resolveSwing(club, clamp(val,0,1), powerVal);
  }
}

/* ===== Physics & outcome ===== */
const OUT={ TREES:"trees", ROUGH_L:"roughL", FAIRWAY:"fairway", ROUGH_R:"roughR", WATER:"water", SAND:"sand", GREEN:"green", CUP:"cup" };
function lastOutcome(){ const h=STATE._history; return h.length? h[h.length-1].outcome : null; }

function computeToByCarry(from, progress, lateral){
  return {
    x: clamp(from.x + progress*0.82, 0.04, 0.97),
    y: clamp(from.y + lateral*0.60, 0.18, 0.82)
  };
}
function computeToTowardHole(from, frac){ return { x: lerp(from.x, HOLE.x, frac), y: lerp(from.y, HOLE.y, frac) }; }

async function animateArcOnMini(from, to, isPutt, clubId){
  const cv=miniCanvas; if(!cv) return;
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const bb=cv.getBoundingClientRect(); 
  const dist = Math.hypot((to.x-from.x),(to.y-from.y));
  let dur = isPutt ? Math.max(PACE.puttFlightMin, PACE.flightBase*0.7 + PACE.flightPerUnit*dist*0.6)
                   : (PACE.flightBase + PACE.flightPerUnit*dist);
  const loft = loftFactor(clubId);
  const arc = isPutt ? 0.00 : clamp(loft * Math.max(0.12, dist*0.7), 0.06, 0.30);

  const start = performance.now();
  const idx = STATE.path.length-1;
  const easeInOut=t=>t<0.5?2*t*t:-1+(4-2*t)*t;
  const B=(t,a,b,c)=> (1-t)*(1-t)*a + 2*(1-t)*t*b + t*t*c;

  while(true){
    const t0 = (performance.now()-start)/dur;
    const t = clamp(easeInOut(t0),0,1);
    const midx=(from.x+to.x)/2, midy=(from.y+to.y)/2 - arc;
    const cx=B(t,from.x,midx,to.x), cy=B(t,from.y,midy,to.y);
    STATE.path[idx]={x:cx,y:cy};
    drawMini(cv, STATE.onGreen);
    if(t0>=1) break;
    await sleep(16);
  }
  STATE.path[idx] = {x:to.x, y:to.y};
  drawMini(cv, STATE.onGreen);
}

async function resolveSwing(club, angle, power){
  STATE.shots++;

  // ===== Putting (single tap; generous capture) =====
  if(club.kind==="putt" || STATE.onGreen){
    STATE.onGreen=true;

    const target = Math.max(1, STATE.distFt || 0);
    const hitFt  = clamp(power*club.max, 0, club.max);

    const from = STATE.path[STATE.path.length-1];

    if(puttAutoMake(hitFt, target) || Math.random() < pgaMakeProb(target)*0.25){
      // Drops (auto capture or lucky trickle)
      const to = {x:HOLE.x, y:HOLE.y};
      STATE.path.push({x:from.x, y:from.y});
      await animateArcOnMini(from, to, true, 'putter');
      pushHistory(OUT.CUP, club.name); SFX.cup.play();
      await typeRemark(choice(REMARKS.cup));
      return finishRound();
    } else {
      // Miss: roll proportionally; leave distance = |miss| with a touch of cushion
      const frac = clamp(hitFt / Math.max(1,target), 0.05, 0.98);
      const to = computeToTowardHole(from, frac);
      STATE.path.push({x:from.x, y:from.y});
      await animateArcOnMini(from, to, true, 'putter');

      const leave = Math.max(1, Math.abs(hitFt - target) + 1.0);
      STATE.distFt = leave;
      pushHistory(OUT.GREEN, club.name);
      await typeRemark(choice(REMARKS.green));
      await sleep(PACE.betweenShots);
      return sceneClubSelect();
    }
  }

  // ===== Full shot =====
  let lie=1; const prev=lastOutcome();
  if(prev===OUT.TREES) lie=0.5;
  else if(prev===OUT.ROUGH_L||prev===OUT.ROUGH_R||prev===OUT.SAND) lie=0.9;

  const effMax=club.max*lie;
  let carry = clamp(power*effMax, 10, effMax);
  const before=STATE.distYds;
  let after=Math.max(0, before - carry);

  const lateral = angle - 0.5;
  let outcome = OUT.FAIRWAY;

  // Hazards thresholds from tee:
  const TREES_ACTIVE = before >= 109;
  const WATER_ACTIVE = before >= 209;

  if(TREES_ACTIVE && (angle < club.anglePenalty) && lateral<0){ outcome = OUT.TREES; }
  if(WATER_ACTIVE && (angle > 1 - club.anglePenalty) && lateral>0){ outcome = OUT.WATER; }

  // Fairway bunker logic
  if(outcome===OUT.FAIRWAY && after<=80 && after>=40 && lateral < -0.08){
    outcome = OUT.SAND;
  }

  // Near green classification
  if(after<=60 && outcome===OUT.FAIRWAY){
    if(lateral<-0.10) outcome=OUT.SAND;
    else if(Math.abs(lateral)<=0.18) outcome=OUT.GREEN;
    else outcome=(lateral<0)? OUT.ROUGH_L : OUT.ROUGH_R;
  } else if(outcome===OUT.FAIRWAY){
    if(Math.abs(lateral)<=0.18) outcome=OUT.FAIRWAY;
    else outcome=(lateral<0)? OUT.ROUGH_L : OUT.ROUGH_R;
  }

  if(outcome===OUT.WATER){
    STATE.penalties++; SFX.splash.play(); outcome=OUT.ROUGH_R;
  }

  // Update distances
  if(outcome===OUT.GREEN){ STATE.onGreen=true; STATE.distFt=Math.max(3, Math.round(after*3)); }
  else { STATE.onGreen=false; STATE.distYds=Math.max(1, after); }

  // Animate
  const from = STATE.path[STATE.path.length-1];
  const to   = computeToByCarry(from, carry/before, lateral);
  STATE.path.push({x:from.x, y:from.y});
  await animateArcOnMini(from, to, false, club.id);

  // Remark
  let line="";
  if(outcome===OUT.FAIRWAY) line=choice(REMARKS.fairway);
  else if(outcome===OUT.ROUGH_L||outcome===OUT.ROUGH_R) line=choice(REMARKS.rough);
  else if(outcome===OUT.TREES) line=choice(REMARKS.trees);
  else if(outcome===OUT.SAND) line=choice(REMARKS.sand);
  else if(outcome===OUT.GREEN) line=choice(REMARKS.green);
  else line="Nice move. Keep walking.";

  pushHistory(outcome, club.name);
  await typeRemark(line);
  await sleep(PACE.betweenShots);
  sceneClubSelect();
}

/* ===== History & finish ===== */
function pushHistory(outcome,club){ STATE._history.push({outcome,club,shots:STATE.shots,pen:STATE.penalties,onGreen:STATE.onGreen,distYds:STATE.distYds,distFt:STATE.distFt}); }

function finishRound(){ const strokes=STATE.shots+STATE.penalties; finishScreen(strokes, null); }
async function finishPickup(){ const par=4, minScore=par+2; STATE.pickedUp=true; const strokes=Math.max(STATE.shots+STATE.penalties, minScore); await typeRemark("Pocket the ball. Fresh start."); finishScreen(strokes, "Picked up"); }
function finishScreen(strokes, tag){
  STATE.finished=true; const par=4, diff=strokes-par;
  const label = tag?tag:(diff<=-2?"Eagle":diff===-1?"Birdie":diff===0?"Par":diff===1?"Bogey":"+ "+diff);
  $("#scene").innerHTML=`
    <div id="typeHeader"></div>
    <div class="card panel stack" style="padding:22px;max-width:900px;margin:20px auto">
      <div class="pill">Final</div>
      <h2 style="margin:0;font-family:'Libre Baskerville',serif">${strokes} • ${label}</h2>
      <div class="row"><div class="pill">Shots: ${STATE.shots}</div><div class="pill">Penalties: ${STATE.penalties}</div></div>
      <div class="row">
        <button id="again">Restart</button>
        <button class="secondary" id="store">Visit the store</button>
        <button id="lb" class="secondary">Leaderboard</button>
      </div>
      <div class="row">
        <input id="init" maxlength="3" placeholder="ABC" style="padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.2);color:var(--cream)">
        <button id="save">Save Score</button>
      </div>
      <div id="msg" class="small"></div>
    </div>`;
  $("#again").onclick=()=>{ $("#typeHeader").textContent=""; resetState(); sceneClubSelect(); };
  $("#store").onclick=()=>location.href="https://bogeyhound.com";
  $("#lb").onclick=sceneLeaderboard;
  $("#save").onclick=()=>{ const i=($("#init").value||"__").toUpperCase().replace(/[^A-Z]/g,"").slice(0,3).padEnd(3,"_"); saveLB(i,strokes, tag||""); $("#msg").textContent="Saved."; };
}

/* ===== Boot: draw blank mini once ===== */
drawMini(miniCanvas,false);
</script>
</body>
</html>